# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/feature/cards.ipynb.

# %% auto 0
__all__ = ['optional_parts', 'Cards_API_Exception', 'generate_search_cards_only_apps_filter', 'search_cards', 'get_card_by_id',
           'DomoCard', 'Card_DownloadSourceCode']

# %% ../../nbs/feature/cards.ipynb 2
from dataclasses import dataclass, field

from typing import List, Any

import mbison.client.core as dmda
import mbison.client.utils as dmut
from copy import deepcopy

from nbdev.showdoc import patch_to

import json
import os

# %% ../../nbs/feature/cards.ipynb 7
class Cards_API_Exception(dmda.API_Exception):
    def __init__(self, res, message=None):

        super().__init__(res=res, message=message)

# %% ../../nbs/feature/cards.ipynb 8
def generate_search_cards_only_apps_filter():
    return {
        "includeCardTypeClause": True,
        "cardTypes": ["domoapp", "mason", "custom"],
        "ascending": True,
        "orderBy": "cardTitle",
    }

def search_cards(
    auth: dmda.DomoAuth,
    query: dict = None,
    debug_api: bool = False,
    return_raw: bool = False,
    debug_loop: bool = False,
    limit: int = 100,
    offset: int = 0,
    optional_parts : str = 'certification,datasources,drillPath,owners,properties,domoapp'
):

    endpoint = "/api/content/v2/cards/adminsummary"
    query = query or {}
    


    def arr_fn(res):
        if res.status == 429:
            return []
        
        return res.response.get("cardAdminSummaries", [])
    
    res = dmda.looper(
        auth=auth,
        arr_fn=arr_fn,
        offset_params={"limit": "limit", "offset": "skip"},
        offset_params_is_header=True,
        params = {'parts': optional_parts},

        request_type="POST",
        endpoint=endpoint,

        debug_api=debug_api,
        return_raw=return_raw,
        debug_loop=debug_loop, 

        # params = params

        body=query,
        limit=limit,
        offset=offset,

    )

    if not res.is_success:
        print(res)
        raise Cards_API_Exception(res=res)

    return res

# %% ../../nbs/feature/cards.ipynb 10
optional_parts = [
    "certification",
    "datasources",
    "domoapp",
    "drillPath",
    "masonData",
    "metadata",
    "owners",
    "problems",
    "properties",
]


def get_card_by_id(card_id, auth: dmda.DomoAuth, optional_parts = 'certification,datasources,drillPath,owners,properties,domoapp', debug_api: bool = False, return_raw: bool = False):
    endpoint = "/api/content/v1/cards/"

    params = {"parts": optional_parts, "urns": card_id}

    res = dmda.domo_api_request(

        auth=auth,

        request_type="GET",
        endpoint=endpoint,

        debug_api=debug_api,
        params=params,

    )

    if not res.is_success:
        raise Cards_API_Exception(res=res)
    
    if return_raw:
        return res
    
    res.response = res.response[0]
    

    return res

# %% ../../nbs/feature/cards.ipynb 13
@dataclass
class DomoCard:
    id: str
    auth: dmda.DomoAuth = field(repr=False)
    title: str = None
    description: str = None
    type: str = None
    urn: str = None
    chart_type: str = None
    dataset_id: str = None

    datastore_id : str = None
    
    domo_collections: List[Any] = None
    domo_source_code : Any = None

    owners: List[any] = None

    def display_url(self) -> str:
        return f"https://{self.auth.domo_instance}.domo.com/kpis/details/{self.id}"
    

    @classmethod
    def _from_json(cls, obj : dict, auth: dmda.DomoAuth):

        card = cls(
            auth=auth,
            id=obj['id'],
            title=obj['title'],
            type= obj['type'],
            urn= obj['urn'],
            description= obj.get('description'),
            owners = obj.get('owners')
        )

        if obj.get('domoapp',{}).get('id'):
            card.datastore_id = obj['domoapp']['id']
    
        return card

    @classmethod
    def get_by_id(
        cls,
        card_id: str,
        auth: dmda.DomoAuth,
        debug_api: bool = False,
        return_raw: bool = False
    ):
        res = get_card_by_id(
            auth=auth,
            card_id=card_id, 
            debug_api=debug_api
        )

        if return_raw:
            return res


        return cls._from_json(res.response, auth)


# %% ../../nbs/feature/cards.ipynb 15
class Card_DownloadSourceCode(dmda.Class_Exception):
    def __init__(self, cls, auth, message):
        super().__init__(cls = cls, auth = auth, message = message)



@patch_to(DomoCard)
def get_collections(self, debug_api: bool = False, return_raw: bool = False):
    import mbison.feature.appdb as dmdb

    res = dmdb.get_collections(
        datastore_id=self.datastore_id, auth=self.auth, debug_api=debug_api
    )

    if return_raw:
        return res

    self.domo_collections = [
        dmdb.AppDbCollection.get_by_id(
            collection_id=obj["id"], auth=self.auth, debug_api=debug_api
        )
        for obj in res.response
    ]

    return self.domo_collections


@patch_to(DomoCard)
def get_source_code(self, debug_api: bool = False, try_auto_share: bool = False):

    self.get_collections(debug_api=debug_api)

    collection_name = "ddx_app_client_code"
    code_collection = next(
        (
            domo_collection
            for domo_collection in self.domo_collections
            if domo_collection.name == collection_name
        ),
        None,
    )

    if not code_collection:
        raise Card_DownloadSourceCode(
            cls=deepcopy(self),
            auth=self.auth,
            message=f"collection - {collection_name} not found for {self.title} - {self.id}",
        )

    documents = code_collection.query_documents(
        debug_api=debug_api, try_auto_share=try_auto_share
    )

    if not documents:
        raise Card_DownloadSourceCode(
            cls=deepcopy(self),
            auth=self.auth,
            message=f"collection - {collection_name} - {code_collection.id} - unable to retrieve documents for {self.title} - {self.id}",
        )

    self.domo_source_code = documents[0]

    return self.domo_source_code


@patch_to(DomoCard)
def download_source_code(
    self,
    download_folder="./EXPORT/",
    file_name=None,
    debug_api: bool = False,
    try_auto_share: bool = False,
):
    doc = self.get_source_code(debug_api=debug_api, try_auto_share=try_auto_share)

    if file_name:
        download_path = os.path.join(
            download_folder, dmut.change_suffix(file_name, new_extension=".json")
        )
        dmut.upsert_folder(download_path)

        with open(download_path, "w+", encoding="utf-8") as f:
            f.write(json.dumps(doc.content))
            return doc

    ddx_type = next(iter(doc.content))


    for key, value in doc.content[ddx_type].items():
        if key == "js":
            file_name = "app.js"
        elif key == "html":
            file_name = "index.html"
        elif key == "css":
            file_name = "styles.css"
        else:
            file_name = f"{key}.txt"

        download_path = os.path.join(
            download_folder, f"{ddx_type}/{self.id}/{file_name}"
        )
        dmut.upsert_folder(download_path)

        with open(download_path, "w+", encoding="utf-8") as f:
            f.write(value)

    return doc
