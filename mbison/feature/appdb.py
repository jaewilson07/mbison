# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/feature/appdb.ipynb.

# %% auto 0
__all__ = ['AppDb_API_Exception', 'get_collections', 'get_collection_by_id', 'query_collection_documents',
           'get_collection_document_by_id', 'Collection_Permission_Enum', 'modify_collection_permissions', 'to_json',
           'AppDbDocument', 'AppDbCollection']

# %% ../../nbs/feature/appdb.ipynb 3
from dataclasses import dataclass, field
from enum import Enum


from typing import List
import datetime as dt
from numbers import Number

import mbison.client.core as dmda
import mbison.client.utils as dmut

# %% ../../nbs/feature/appdb.ipynb 8
class AppDb_API_Exception(dmda.API_Exception):
    def __init__(self, res, message=None):

        super().__init__(res=res, message=message)

# %% ../../nbs/feature/appdb.ipynb 9
def get_collections(
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    datastore_id : str = None, # filters for a specific datastoreId
):
    """retrieve collections"""

    endpoint = f"/api/datastores/v1/collections/"

    res =  dmda.domo_api_request(
        auth=auth,
        request_type="GET",
        endpoint= endpoint,
        debug_api=debug_api,
        params = {'datastoreId': datastore_id}
    )

    if not res.is_success and res.status == 400:
        raise AppDb_API_Exception(res, message = f"invalid datastoreId  - {datastore_id}?")

    if not res.is_success:
        raise AppDb_API_Exception(res)
    
    return res

# %% ../../nbs/feature/appdb.ipynb 11
def get_collection_by_id(
    auth: dmda.DomoAuth,
    collection_id : str,
    debug_api: bool = False,
):

    endpoint = f"/api/datastores/v1/collections/{collection_id}"

    res =  dmda.domo_api_request(
        auth=auth,
        request_type="GET",
        endpoint= endpoint,
        debug_api=debug_api,
    )

    if not res.is_success:
        raise AppDb_API_Exception(res)
    
    return res

# %% ../../nbs/feature/appdb.ipynb 13
def query_collection_documents(
    auth: dmda.DomoAuth,
    collection_id: str,
    query : dict = None,
    debug_api : bool = False
):
    endpoint = f'/api/datastores/v2/collections/{collection_id}/documents/query'

    query = query or {}

    res =  dmda.domo_api_request(
        auth=auth,
        request_type="POST",
        endpoint= endpoint,
        debug_api=debug_api,
        body = query
    )

    if not res.is_success:
        raise AppDb_API_Exception(res, message = f"unable to query documents in collection - {collection_id}")
    
    return res


# %% ../../nbs/feature/appdb.ipynb 15
def get_collection_document_by_id(
    auth: dmda.DomoAuth,
    collection_id: str,
    document_id : str,
    query : dict = None,
    debug_api : bool = False
):
    endpoint = f'/api/datastores/v2/collections/{collection_id}/documents/{document_id}'

    query = query or {}

    res =  dmda.domo_api_request(
        auth=auth,
        request_type="GET",
        endpoint= endpoint,
        debug_api=debug_api,
        body = query
    )

    if not res.is_success:
        raise AppDb_API_Exception(res)
    
    return res


# %% ../../nbs/feature/appdb.ipynb 17
class Collection_Permission_Enum(Enum):
    READ_CONTENT = 'READ_CONTENT'
    ADMIN = 'ADMIN'
    UPDATE_CONTENT = 'UPDATE_CONTENT'

def modify_collection_permissions(
    collection_id : str ,
    user_id: str,
    auth :dmda.DomoAuth,
    permission = Collection_Permission_Enum.READ_CONTENT,
    debug_api: bool = False
):

    endpoint = f'/api/datastores/v1/collections/{collection_id}/permission/USER/{user_id}'
    params = {'overwrite' : True, 'permissions' : permission.value if isinstance(permission, Collection_Permission_Enum) else permission}

              
    res =  dmda.domo_api_request(
        auth=auth,
        request_type="PUT",
        params = params,
        endpoint= endpoint,
        debug_api=debug_api,
    )

    if not res.is_success:
        raise AppDb_API_Exception(res, message = "unable to set permissions for {user_id} to {permission.value} in collection {collection_id}")
    
    return res

# %% ../../nbs/feature/appdb.ipynb 20
def to_json(value):
    """
    converts complex dictionaries with nested classes to dictionary.
    assumes nested classes have a `to_json` method
    """

    if hasattr(value, "to_json"):
        return value.to_json()

    if isinstance(value, dict):
        return {key: to_json(v) for key, v in value.items()}

    if isinstance(value, list):
        return [to_json(v) for v in value]

    if isinstance(value, Number):
        return value

    return str(value)


@dataclass
class AppDbDocument:

    auth: dmda.DomoAuth = field(repr=False)

    # document metadata
    _collection_id: str
    _identity_columns: List[str]
    _id: str = None
    _created_on_dt: dt.datetime = None
    _updated_on_dt: dt.datetime = None

    content: dict = None

    def to_json(self):
        # TO DO - this is not a complete recursive implementation,  may need revision for complex dictionaries
        self.update_config()

        s = {"id": self._id, "collectionId": self._collection_id}

        for key, value in self.__dict__.items():
            if key.startswith("_") or key in ["auth"]:
                continue

            s.update({key: to_json(value)})

        return s

    def __eq__(self, other):
        if self.__class__.__name__ != other.__class__.__name__:
            return False

        if self._identity_columns:
            return all(
                getattr(self, col) == getattr(other.col)
                for col in self._identity_columns
            )

        return self._id == other._id

    @classmethod
    def _from_json(
        cls,
        auth: dmda.DomoAuth,
        content,
        new_cls,
        identity_columns,
        collection_id=None,
        document_id=None,
        metadata=None,
        created_on_dt=None,
        updated_on_dt=None,
    ):

        if metadata:
            collection_id = metadata.pop("collectionId")

            created_on_dt = dmut.convert_string_to_datetime(metadata.pop("createdOn"))

            updated_on_dt = dmut.convert_string_to_datetime(metadata.pop("updatedOn"))
            document_id = metadata["id"]

        return new_cls(
            auth=auth,
            _id=document_id,
            _identity_columns=identity_columns,
            _collection_id=collection_id,
            _created_on_dt=created_on_dt,
            _updated_on_dt=updated_on_dt,
            content=content,
            **(content if cls.__name__ != "AppDbDocument" else {})
        )

    @classmethod
    def _from_api(
        cls,
        auth: dmda.DomoAuth,
        obj,
        identity_columns: List[str] = None,
    ):
        content = obj.pop("content")

        return cls._from_json(
            auth=auth,
            content=content,
            new_cls=cls,
            identity_columns=identity_columns,
            metadata=obj,
        )

    @classmethod
    def from_json(
        cls,
        auth: dmda.DomoAuth,
        collection_id: str,
        content: dict,
        identity_columns: List[str] = None,
    ):
        return cls._from_json(
            auth=auth,
            content=content,
            new_cls=cls,
            identity_columns=identity_columns,
            collection_id=collection_id,
        )

    def update_config(self):
        self.content = {
            key: value
            for key, value in self.__dict__.items()
            if key not in ["auth", "content"] and not key.startswith("_")
        }
        return self.content

    @classmethod
    def get_by_id(
        cls,
        collection_id: str,
        document_id: str,
        auth: dmda.DomoAuth,
        identity_columns=None,
        debug_api: bool = False,
        return_raw: bool = False,
    ):
        res = get_collection_document_by_id(
            auth=auth,
            collection_id=collection_id,
            document_id=document_id,
            debug_api=debug_api,
        )

        if return_raw:
            return res

        return cls._from_api(
            auth=auth,
            obj=res.response,
            identity_columns=identity_columns or [],
        )


# %% ../../nbs/feature/appdb.ipynb 22
@dataclass
class AppDbCollection:
    auth: dmda.DomoAuth = field(repr=False)
    id: str
    name: str

    created_on_dt: dt.datetime
    updated_on_dt: dt.datetime

    schema: dict

    domo_documents: List[AppDbDocument] = None

    @classmethod
    def _from_json(cls, auth, obj):

        return cls(
            auth=auth,
            id=obj["id"],
            name=obj["name"],
            created_on_dt=dmut.convert_string_to_datetime(obj["createdOn"]),
            updated_on_dt=dmut.convert_string_to_datetime(obj["updatedOn"]),
            schema=obj["schema"],
        )

    @classmethod
    def get_by_id(
        cls,
        auth: dmda.DomoAuth,
        collection_id,
        debug_api: bool = False,
        return_raw: bool = False,
    ):

        res = get_collection_by_id(
            auth=auth,
            collection_id=collection_id,
            debug_api=debug_api,
        )

        if return_raw:
            return res

        return cls._from_json(auth=auth, obj=res.response)

    def query_documents(
        self,
        debug_api: bool = False,
        query: dict=None,
        return_raw: bool = False,
    ):

        res = query_collection_documents(
            auth=self.auth,
            collection_id=self.id,
            debug_api=debug_api,
            query=query,
        )

        if return_raw:
            return res

        self.domo_documents = [
                AppDbDocument.get_by_id(
                    collection_id=self.id,
                    document_id=doc["id"], auth=self.auth
                )
                for doc in res.response
            ]
        
        return self.domo_documents

    def __eq__(self, other):
        if not isinstance(other, AppDbCollection):
            return False

        return self.id == other.id
