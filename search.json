[
  {
    "objectID": "feature/datasets.html",
    "href": "feature/datasets.html",
    "title": "Dataset",
    "section": "",
    "text": "from dataclasses import dataclass, field\n\nfrom typing import List\n\nimport mbison.client.core as dmda\n\n\n\n\nsource\n\n\n\n get_datasets (auth:mbison.client.core.DomoAuth, debug_api:bool=False,\n               return_raw:bool=False)\n\n\n\nExported source\ndef get_datasets(\n    auth: dmda.DomoAuth, debug_api: bool = False, return_raw: bool = False\n):\n    endpoint = \"/api/data/ui/v3/datasources/search\"\n\n    payload = {\n        \"entities\": [\"DATASET\"],\n        \"filters\": [],\n        \"combineResults\": \"true\",\n        \"query\": \"*\",\n        \"count\": 1000,\n        \"offset\": 0,\n        \"sort\": {\n            \"isRelevance\": \"false\",\n            \"fieldSorts\": [{\"field\": \"create_date\", \"sortOrder\": \"DESC\"}],\n        },\n    }\n\n    res = dmda.domo_api_request(\n        auth=auth,\n        endpoint=endpoint,\n        request_type=\"POST\",\n        debug_api=debug_api,\n        body=payload,\n    )\n\n    if return_raw:\n        return res\n\n    res.response = res.response[\"dataSources\"]\n\n    return res\n\n\n\nauth = dmda.DomoAuth(\n    domo_instance=os.environ[\"DOMO_INSTANCE\"],\n    access_token=os.environ[\"DOMO_ACCESS_TOKEN\"],\n)\n\n\nres = get_datasets(auth=auth, debug_api=False)\n\ndatasets = res.response\ndatasets[0:1]\n\n*** Using Access Token Auth\n\n\n[{'id': 'fedef9a2-eddb-44d1-b0c9-a0023224e8d1',\n  'displayType': 'webform',\n  'dataProviderType': 'webform',\n  'type': 'webform',\n  'name': 'Example Sales Data',\n  'owner': {'id': '1728973208',\n   'name': 'Peter Shull',\n   'type': 'USER',\n   'group': False},\n  'status': 'VALID',\n  'created': 1721655313000,\n  'lastUpdated': 1721655316205,\n  'dataLastUpdated': 0,\n  'rowCount': 19378,\n  'columnCount': 5,\n  'cardInfo': {'cardCount': 2, 'cardViewCount': 0},\n  'state': 'VALID',\n  'validConfiguration': True,\n  'validAccount': True,\n  'transportType': 'WEBFORM',\n  'adc': False,\n  'adcExternal': False,\n  'cloudId': 'domo',\n  'cloudName': 'Domo',\n  'hidden': False,\n  'tagsList': [],\n  'schema': {'name': 'fedef9a2-eddb-44d1-b0c9-a0023224e8d1',\n   'tables': [{'columns': [{'name': 'date_ymd',\n       'id': 'date_ymd',\n       'type': 'DATE',\n       'visible': True,\n       'order': 0},\n      {'name': 'revenue',\n       'id': 'revenue',\n       'type': 'DOUBLE',\n       'visible': True,\n       'order': 0},\n      {'name': 'sales_rep',\n       'id': 'sales_rep',\n       'type': 'STRING',\n       'visible': True,\n       'order': 0},\n      {'name': 'department',\n       'id': 'department',\n       'type': 'STRING',\n       'visible': True,\n       'order': 0},\n      {'name': 'state',\n       'id': 'state',\n       'type': 'STRING',\n       'visible': True,\n       'order': 0}]}]},\n  'alertCount': 0,\n  'dataFlowCount': 0,\n  'dataSourceCount': 0,\n  'impactCardCount': 2,\n  'impactAlertCount': 0,\n  'impactDataFlowCount': 0,\n  'impactDataSourceCount': 0}]\n\n\n\nsource\n\n\n\n\n get_pdp_policy (auth:mbison.client.core.DomoAuth, datasetId, policy_id)\n\n\n\nExported source\ndef get_pdp_policies(auth: dmda.DomoAuth, datasetId):\n    endpoint = f\"/api/query/v1/data-control/{datasetId}/filter-groups\"\n\n    params = {\"options\": \"load_associations,load_filters,include_open_policy\"}\n\n    response = dmda.domo_api_request(\n        endpoint=endpoint, auth=auth, request_type=\"GET\", params=params\n    )\n\n    return response\n\n\ndef get_pdp_policy(auth: dmda.DomoAuth, datasetId, policy_id):\n    endpoint = f\"/api/query/v1/data-control/{datasetId}/filter-groups/{policy_id}\"\n\n    res = dmda.domo_api_request(\n        auth=auth,\n        method=\"GET\",\n        endpoint=endpoint,\n        params={\"options\": \"load_associations,load_filters,include_open_policy\"},\n    )\n\n    return res\n\n\n\nsource\n\n\n\n\n get_pdp_policies (auth:mbison.client.core.DomoAuth, datasetId)\n\n\nget_pdp_policies(auth=auth, datasetId=datasets[0][\"id\"])\n\nResponseGetData(response=[{'name': 'All Rows', 'filterGroupId': 2380, 'dataSourceId': 'fedef9a2-eddb-44d1-b0c9-a0023224e8d1', 'type': 'open', 'dataSourcePermissions': False, 'order': 0}], is_success=True, status=200)\n\n\n\nsource\n\n\n\n\n delete_pdp_policy (auth:mbison.client.core.DomoAuth, datasetId, policyId)\n\n\n\nExported source\ndef create_pdp_policy(auth: dmda.DomoAuth, datasetId: str, pdp_object: dict):\n\n    endpoint = f\"/api/query/v1/data-control/{datasetId}/filter-groups\"\n\n    res = dmda.domo_api_request(\n        auth=auth, request_type=\"POST\", endpoint=endpoint, body=pdp_object\n    )\n\n    return res\n\n\ndef update_pdp_policy(auth: dmda.DomoAuth, datasetId, policyId, pdp_object: dict):\n    endpoint = f\"/api/query/v1/data-control/{datasetId}/filter-groups/{policyId}\"\n\n    res = dmda.domo_api_request(\n        auth=auth,\n        request_type=\"PUT\",\n        endpoint=endpoint,\n        body=pdp_object,\n    )\n\n    return res\n\n\ndef delete_pdp_policy(auth: dmda.DomoAuth, datasetId, policyId):\n    endpoint = f\"/api/query/v1/data-control/{datasetId}/filter-groups/{policyId}\"\n\n    res = dmda.domo_api_request(auth=auth, endpoint=endpoint, request_type=\"DELETE\")\n\n    return res\n\n\n\nsource\n\n\n\n\n update_pdp_policy (auth:mbison.client.core.DomoAuth, datasetId, policyId,\n                    pdp_object:dict)\n\n\nsource\n\n\n\n\n create_pdp_policy (auth:mbison.client.core.DomoAuth, datasetId:str,\n                    pdp_object:dict)\n\n\n\n\n\n\nsource\n\n\n\n DomoDataset (id:str, name:str, auth:mbison.client.core.DomoAuth,\n              pdp_policies:List[dict]=None,\n              domo_policies:List[__main__.DomoDatasetPolicy]=None)\n\n\n\nExported source\n@dataclass\nclass DomoDatasetPolicy:\n    name: str\n\n\n@dataclass\nclass DomoDataset:\n    id: str\n    name: str\n\n    auth: dmda.DomoAuth\n\n    pdp_policies: List[dict] = None\n    domo_policies: List[DomoDatasetPolicy] = None\n\n    @classmethod\n    def _from_json(cls, auth: dmda.DomoAuth, obj: dict):\n        return cls(auth=auth, id=obj[\"id\"], name=obj[\"name\"])\n\n    def get_pdp_policies(self, return_raw: bool = False):\n\n        res = get_pdp_policies(auth=self.auth, datasetId=self.id)\n\n        if return_raw:\n            return res\n\n        self.pdp_policies = res.response\n        self.domo_policies = [\n            DomoDatasetPolicy(name=obj[\"name\"]) for obj in self.pdp_policies\n        ]\n\n        return self.domo_policies\n\n\n\nsource\n\n\n\n\n DomoDatasetPolicy (name:str)\n\n\nsource\n\n\n\n\n DomoDatasets (auth:mbison.client.core.DomoAuth,\n               raw_datasets:List[dict]=&lt;factory&gt;,\n               domo_datasets:List[__main__.DomoDataset]=&lt;factory&gt;)\n\n\n\nExported source\n@dataclass\nclass DomoDatasets:\n    auth: dmda.DomoAuth\n    raw_datasets: List[dict] = field(default_factory=lambda: [])\n\n    domo_datasets: List[DomoDataset] = field(default_factory=lambda: [])\n\n    def get_datasets(self, debug_api: bool = False, return_raw: bool = False):\n\n        res = get_datasets(self.auth, debug_api=debug_api)\n\n        if return_raw:\n            return res\n\n        self.raw_datasets = res.response\n\n        self.domo_datasets = [\n            DomoDataset._from_json(obj=obj, auth=self.auth) for obj in self.raw_datasets\n        ]\n\n        return self.domo_datasets\n\n    def print_datasets(self):\n        print(self.domo_datasets)\n\n\n\ndomo_datasets = DomoDatasets(auth=auth)\ndomo_datasets.get_datasets()[0:5]\n\n[DomoDataset(id='fedef9a2-eddb-44d1-b0c9-a0023224e8d1', name='Example Sales Data', auth=DomoAuth(domo_instance='domo-community', username=None), pdp_policies=None, domo_policies=None),\n DomoDataset(id='37fdfa92-ba60-4ab0-8f95-a03c6af543f0', name='Output2', auth=DomoAuth(domo_instance='domo-community', username=None), pdp_policies=None, domo_policies=None),\n DomoDataset(id='4823950f-d754-474b-bddc-a6e7fec6df34', name='Output1', auth=DomoAuth(domo_instance='domo-community', username=None), pdp_policies=None, domo_policies=None),\n DomoDataset(id='f17bae29-3caa-4408-afbd-e2130b7281a5', name='HarryPotter', auth=DomoAuth(domo_instance='domo-community', username=None), pdp_policies=None, domo_policies=None),\n DomoDataset(id='7e8c4e24-6169-4e3b-ae51-65e4305b2e80', name='form_data_a2693a83-a265-4a27-8a4f-a0d4778273ba_APP_DB', auth=DomoAuth(domo_instance='domo-community', username=None), pdp_policies=None, domo_policies=None)]\n\n\n\ndomo_datasets.domo_datasets[0].get_pdp_policies()\n\n[DomoDatasetPolicy(name='All Rows')]",
    "crumbs": [
      "feature",
      "Dataset"
    ]
  },
  {
    "objectID": "feature/datasets.html#routes",
    "href": "feature/datasets.html#routes",
    "title": "Dataset",
    "section": "",
    "text": "source\n\n\n\n get_datasets (auth:mbison.client.core.DomoAuth, debug_api:bool=False,\n               return_raw:bool=False)\n\n\n\nExported source\ndef get_datasets(\n    auth: dmda.DomoAuth, debug_api: bool = False, return_raw: bool = False\n):\n    endpoint = \"/api/data/ui/v3/datasources/search\"\n\n    payload = {\n        \"entities\": [\"DATASET\"],\n        \"filters\": [],\n        \"combineResults\": \"true\",\n        \"query\": \"*\",\n        \"count\": 1000,\n        \"offset\": 0,\n        \"sort\": {\n            \"isRelevance\": \"false\",\n            \"fieldSorts\": [{\"field\": \"create_date\", \"sortOrder\": \"DESC\"}],\n        },\n    }\n\n    res = dmda.domo_api_request(\n        auth=auth,\n        endpoint=endpoint,\n        request_type=\"POST\",\n        debug_api=debug_api,\n        body=payload,\n    )\n\n    if return_raw:\n        return res\n\n    res.response = res.response[\"dataSources\"]\n\n    return res\n\n\n\nauth = dmda.DomoAuth(\n    domo_instance=os.environ[\"DOMO_INSTANCE\"],\n    access_token=os.environ[\"DOMO_ACCESS_TOKEN\"],\n)\n\n\nres = get_datasets(auth=auth, debug_api=False)\n\ndatasets = res.response\ndatasets[0:1]\n\n*** Using Access Token Auth\n\n\n[{'id': 'fedef9a2-eddb-44d1-b0c9-a0023224e8d1',\n  'displayType': 'webform',\n  'dataProviderType': 'webform',\n  'type': 'webform',\n  'name': 'Example Sales Data',\n  'owner': {'id': '1728973208',\n   'name': 'Peter Shull',\n   'type': 'USER',\n   'group': False},\n  'status': 'VALID',\n  'created': 1721655313000,\n  'lastUpdated': 1721655316205,\n  'dataLastUpdated': 0,\n  'rowCount': 19378,\n  'columnCount': 5,\n  'cardInfo': {'cardCount': 2, 'cardViewCount': 0},\n  'state': 'VALID',\n  'validConfiguration': True,\n  'validAccount': True,\n  'transportType': 'WEBFORM',\n  'adc': False,\n  'adcExternal': False,\n  'cloudId': 'domo',\n  'cloudName': 'Domo',\n  'hidden': False,\n  'tagsList': [],\n  'schema': {'name': 'fedef9a2-eddb-44d1-b0c9-a0023224e8d1',\n   'tables': [{'columns': [{'name': 'date_ymd',\n       'id': 'date_ymd',\n       'type': 'DATE',\n       'visible': True,\n       'order': 0},\n      {'name': 'revenue',\n       'id': 'revenue',\n       'type': 'DOUBLE',\n       'visible': True,\n       'order': 0},\n      {'name': 'sales_rep',\n       'id': 'sales_rep',\n       'type': 'STRING',\n       'visible': True,\n       'order': 0},\n      {'name': 'department',\n       'id': 'department',\n       'type': 'STRING',\n       'visible': True,\n       'order': 0},\n      {'name': 'state',\n       'id': 'state',\n       'type': 'STRING',\n       'visible': True,\n       'order': 0}]}]},\n  'alertCount': 0,\n  'dataFlowCount': 0,\n  'dataSourceCount': 0,\n  'impactCardCount': 2,\n  'impactAlertCount': 0,\n  'impactDataFlowCount': 0,\n  'impactDataSourceCount': 0}]\n\n\n\nsource\n\n\n\n\n get_pdp_policy (auth:mbison.client.core.DomoAuth, datasetId, policy_id)\n\n\n\nExported source\ndef get_pdp_policies(auth: dmda.DomoAuth, datasetId):\n    endpoint = f\"/api/query/v1/data-control/{datasetId}/filter-groups\"\n\n    params = {\"options\": \"load_associations,load_filters,include_open_policy\"}\n\n    response = dmda.domo_api_request(\n        endpoint=endpoint, auth=auth, request_type=\"GET\", params=params\n    )\n\n    return response\n\n\ndef get_pdp_policy(auth: dmda.DomoAuth, datasetId, policy_id):\n    endpoint = f\"/api/query/v1/data-control/{datasetId}/filter-groups/{policy_id}\"\n\n    res = dmda.domo_api_request(\n        auth=auth,\n        method=\"GET\",\n        endpoint=endpoint,\n        params={\"options\": \"load_associations,load_filters,include_open_policy\"},\n    )\n\n    return res\n\n\n\nsource\n\n\n\n\n get_pdp_policies (auth:mbison.client.core.DomoAuth, datasetId)\n\n\nget_pdp_policies(auth=auth, datasetId=datasets[0][\"id\"])\n\nResponseGetData(response=[{'name': 'All Rows', 'filterGroupId': 2380, 'dataSourceId': 'fedef9a2-eddb-44d1-b0c9-a0023224e8d1', 'type': 'open', 'dataSourcePermissions': False, 'order': 0}], is_success=True, status=200)\n\n\n\nsource\n\n\n\n\n delete_pdp_policy (auth:mbison.client.core.DomoAuth, datasetId, policyId)\n\n\n\nExported source\ndef create_pdp_policy(auth: dmda.DomoAuth, datasetId: str, pdp_object: dict):\n\n    endpoint = f\"/api/query/v1/data-control/{datasetId}/filter-groups\"\n\n    res = dmda.domo_api_request(\n        auth=auth, request_type=\"POST\", endpoint=endpoint, body=pdp_object\n    )\n\n    return res\n\n\ndef update_pdp_policy(auth: dmda.DomoAuth, datasetId, policyId, pdp_object: dict):\n    endpoint = f\"/api/query/v1/data-control/{datasetId}/filter-groups/{policyId}\"\n\n    res = dmda.domo_api_request(\n        auth=auth,\n        request_type=\"PUT\",\n        endpoint=endpoint,\n        body=pdp_object,\n    )\n\n    return res\n\n\ndef delete_pdp_policy(auth: dmda.DomoAuth, datasetId, policyId):\n    endpoint = f\"/api/query/v1/data-control/{datasetId}/filter-groups/{policyId}\"\n\n    res = dmda.domo_api_request(auth=auth, endpoint=endpoint, request_type=\"DELETE\")\n\n    return res\n\n\n\nsource\n\n\n\n\n update_pdp_policy (auth:mbison.client.core.DomoAuth, datasetId, policyId,\n                    pdp_object:dict)\n\n\nsource\n\n\n\n\n create_pdp_policy (auth:mbison.client.core.DomoAuth, datasetId:str,\n                    pdp_object:dict)",
    "crumbs": [
      "feature",
      "Dataset"
    ]
  },
  {
    "objectID": "feature/datasets.html#classes",
    "href": "feature/datasets.html#classes",
    "title": "Dataset",
    "section": "",
    "text": "source\n\n\n\n DomoDataset (id:str, name:str, auth:mbison.client.core.DomoAuth,\n              pdp_policies:List[dict]=None,\n              domo_policies:List[__main__.DomoDatasetPolicy]=None)\n\n\n\nExported source\n@dataclass\nclass DomoDatasetPolicy:\n    name: str\n\n\n@dataclass\nclass DomoDataset:\n    id: str\n    name: str\n\n    auth: dmda.DomoAuth\n\n    pdp_policies: List[dict] = None\n    domo_policies: List[DomoDatasetPolicy] = None\n\n    @classmethod\n    def _from_json(cls, auth: dmda.DomoAuth, obj: dict):\n        return cls(auth=auth, id=obj[\"id\"], name=obj[\"name\"])\n\n    def get_pdp_policies(self, return_raw: bool = False):\n\n        res = get_pdp_policies(auth=self.auth, datasetId=self.id)\n\n        if return_raw:\n            return res\n\n        self.pdp_policies = res.response\n        self.domo_policies = [\n            DomoDatasetPolicy(name=obj[\"name\"]) for obj in self.pdp_policies\n        ]\n\n        return self.domo_policies\n\n\n\nsource\n\n\n\n\n DomoDatasetPolicy (name:str)\n\n\nsource\n\n\n\n\n DomoDatasets (auth:mbison.client.core.DomoAuth,\n               raw_datasets:List[dict]=&lt;factory&gt;,\n               domo_datasets:List[__main__.DomoDataset]=&lt;factory&gt;)\n\n\n\nExported source\n@dataclass\nclass DomoDatasets:\n    auth: dmda.DomoAuth\n    raw_datasets: List[dict] = field(default_factory=lambda: [])\n\n    domo_datasets: List[DomoDataset] = field(default_factory=lambda: [])\n\n    def get_datasets(self, debug_api: bool = False, return_raw: bool = False):\n\n        res = get_datasets(self.auth, debug_api=debug_api)\n\n        if return_raw:\n            return res\n\n        self.raw_datasets = res.response\n\n        self.domo_datasets = [\n            DomoDataset._from_json(obj=obj, auth=self.auth) for obj in self.raw_datasets\n        ]\n\n        return self.domo_datasets\n\n    def print_datasets(self):\n        print(self.domo_datasets)\n\n\n\ndomo_datasets = DomoDatasets(auth=auth)\ndomo_datasets.get_datasets()[0:5]\n\n[DomoDataset(id='fedef9a2-eddb-44d1-b0c9-a0023224e8d1', name='Example Sales Data', auth=DomoAuth(domo_instance='domo-community', username=None), pdp_policies=None, domo_policies=None),\n DomoDataset(id='37fdfa92-ba60-4ab0-8f95-a03c6af543f0', name='Output2', auth=DomoAuth(domo_instance='domo-community', username=None), pdp_policies=None, domo_policies=None),\n DomoDataset(id='4823950f-d754-474b-bddc-a6e7fec6df34', name='Output1', auth=DomoAuth(domo_instance='domo-community', username=None), pdp_policies=None, domo_policies=None),\n DomoDataset(id='f17bae29-3caa-4408-afbd-e2130b7281a5', name='HarryPotter', auth=DomoAuth(domo_instance='domo-community', username=None), pdp_policies=None, domo_policies=None),\n DomoDataset(id='7e8c4e24-6169-4e3b-ae51-65e4305b2e80', name='form_data_a2693a83-a265-4a27-8a4f-a0d4778273ba_APP_DB', auth=DomoAuth(domo_instance='domo-community', username=None), pdp_policies=None, domo_policies=None)]\n\n\n\ndomo_datasets.domo_datasets[0].get_pdp_policies()\n\n[DomoDatasetPolicy(name='All Rows')]",
    "crumbs": [
      "feature",
      "Dataset"
    ]
  },
  {
    "objectID": "feature/users.html",
    "href": "feature/users.html",
    "title": "Users",
    "section": "",
    "text": "- get_users() route implemented without loop. default limit is 50.\nauth = dmda.DomoAuth(\n    domo_instance=os.environ[\"DOMO_INSTANCE\"],\n    access_token=os.environ[\"DOMO_ACCESS_TOKEN\"],\n)\n# auth.who_am_i()\nauth\n\n*** Using Access Token Auth\n\n\nDomoAuth(domo_instance='domo-community', username=None)",
    "crumbs": [
      "feature",
      "Users"
    ]
  },
  {
    "objectID": "feature/users.html#routes",
    "href": "feature/users.html#routes",
    "title": "Users",
    "section": "Routes",
    "text": "Routes\n\nsource\n\nget_users\n\n get_users (auth:mbison.client.core.DomoAuth, debug_api:bool=False)\n\nwarning this is a paginated API, need to reimplement with Loop\n\n\nExported source\nclass User_API_Exception(dmda.API_Exception):\n    def __init__(self, res, message=None):\n\n        super().__init__(res=res, message=message)\n\n\ndef get_users(auth: dmda.DomoAuth, debug_api: bool = False):\n    \"\"\"warning this is a paginated API, need to reimplement with Loop\"\"\"\n\n    endpoint = f\"/api/content/v3/users/\"\n\n    params = {\"includeDetails\": True}\n\n    res = dmda.domo_api_request(\n        auth=auth,\n        endpoint=endpoint,\n        request_type=\"GET\",\n        params=params,\n        debug_api=debug_api,\n    )\n\n    if not res.is_success and res.status == 404:\n        raise User_API_Exception(res, message=f\"unable to retrieve users\")\n\n    return res\n\n\n\nsource\n\n\nUser_API_Exception\n\n User_API_Exception (res, message=None)\n\nCommon base class for all non-exit exceptions.\n\nres = get_users(auth=auth, debug_api=False)\n\nprint(len(res.response))\nuser = res.response[0]\nuser\n\n50\n\n\n{'id': 1216550715,\n 'invitorUserId': 1893952720,\n 'displayName': '8:26 - go to sleep',\n 'role': 'Privileged',\n 'roleId': 2,\n 'detail': {'email': 'test4@domo.com',\n  'phoneNumber': '152',\n  'pending': True,\n  'active': True,\n  'created': 1664938821,\n  'modified': 1718758313,\n  'department': 'test'}}\n\n\n\nsource\n\n\nget_user_by_id\n\n get_user_by_id (user_id, auth:mbison.client.core.DomoAuth,\n                 debug_api:bool=False)\n\n\n(get_user_by_id(user_id=user[\"id\"], auth=auth, debug_api=False)).response\n\n{'id': 1216550715,\n 'invitorUserId': 1893952720,\n 'displayName': '8:26 - go to sleep',\n 'role': 'Privileged',\n 'roleId': 2,\n 'detail': {'email': 'test4@domo.com',\n  'phoneNumber': '152',\n  'pending': True,\n  'active': True,\n  'created': 1664938821,\n  'modified': 1718758313,\n  'department': 'test'}}",
    "crumbs": [
      "feature",
      "Users"
    ]
  },
  {
    "objectID": "feature/users.html#classes",
    "href": "feature/users.html#classes",
    "title": "Users",
    "section": "Classes",
    "text": "Classes\n\nsource\n\nDomoUser\n\n DomoUser (auth:mbison.client.core.DomoAuth, id:str, display_name:str,\n           role_id:int, email:str)\n\n\n\nExported source\n@dataclass\nclass DomoUser:\n    auth: dmda.DomoAuth = field(repr=False)\n    id: str\n    display_name: str\n    role_id: int\n    email: str\n\n    @classmethod\n    def from_json(cls, obj, auth: dmda.DomoAuth):\n        return cls(\n            auth=auth,\n            id=obj[\"id\"],\n            display_name=obj[\"displayName\"],\n            role_id=obj[\"roleId\"],\n            email=obj[\"detail\"][\"email\"],\n        )\n\n    @classmethod\n    def get_by_id(\n        cls, user_id, auth, debug_api: bool = False, return_raw: bool = False\n    ):\n        res = get_user_by_id(user_id=user_id, auth=auth, debug_api=debug_api)\n\n        if return_raw:\n            return res\n\n        return cls.from_json(obj=res.response, auth=auth)\n\n\n\nDomoUser.get_by_id(user_id=user[\"id\"], auth=auth)\n\nDomoUser(id=1216550715, display_name='8:26 - go to sleep', role_id=2, email='test4@domo.com')",
    "crumbs": [
      "feature",
      "Users"
    ]
  },
  {
    "objectID": "feature/codeengine.html",
    "href": "feature/codeengine.html",
    "title": "CodeEngine",
    "section": "",
    "text": "auth = dmda.DomoAuth(\n    domo_instance=os.environ[\"DOMO_INSTANCE\"],\n    access_token=os.environ[\"DOMO_ACCESS_TOKEN\"],\n)\nauth",
    "crumbs": [
      "feature",
      "CodeEngine"
    ]
  },
  {
    "objectID": "feature/codeengine.html#routes",
    "href": "feature/codeengine.html#routes",
    "title": "CodeEngine",
    "section": "Routes",
    "text": "Routes\n\nsource\n\nget_packages\n\n get_packages (auth:mbison.client.core.DomoAuth, debug_api:bool=False)\n\n\n\nExported source\ndef get_packages(auth: dmda.DomoAuth, debug_api : bool = False):\n    endpoint = \"/api/codeengine/v2/packages\"\n\n    res = dmda.domo_api_request(endpoint = endpoint,\n                                auth=auth, request_type=\"get\",\n                                debug_api= debug_api\n                                )\n\n    return res\n\n\n\nres = get_packages(auth=auth, debug_api= False)\npackages = res.response\n\npackages[0:1]\n\n\nsource\n\n\nget_package_by_id\n\n get_package_by_id (auth:mbison.client.core.DomoAuth, package_id,\n                    debug_api:bool=False)\n\n\n\nExported source\ndef get_package_by_id(auth: dmda.DomoAuth, package_id, debug_api : bool = False):\n        \n        endpoint = f\"/api/codeengine/v2/packages/{package_id}\"\n                \n        return dmda.domo_api_request(endpoint=endpoint, request_type = 'get', auth=auth, debug_api=debug_api)\n\n\n\nget_package_by_id(auth = auth, package_id = packages[0]['id'])\n\n\nsource\n\n\nget_package_version_by_id\n\n get_package_version_by_id (auth:mbison.client.core.DomoAuth, package_id,\n                            version, debug_api:bool=False)\n\n\n\nExported source\ndef get_package_versions(auth: dmda.DomoAuth, package_id, debug_api : bool = False):\n        \"\"\"each package can have one or many version\"\"\"\n        \n        endpoint = f\"/api/codeengine/v2/packages/{package_id}/versions/\"\n\n        params = {\"parts\" : \" functions,code\"}\n                \n        return dmda.domo_api_request(endpoint=endpoint, request_type = 'get', auth=auth,params=params, debug_api=debug_api)\n\n\ndef get_package_version_by_id(auth: dmda.DomoAuth, package_id, version, debug_api : bool = False):\n        \n        endpoint = f\"/api/codeengine/v2/packages/{package_id}/versions/{version}\"\n\n        params = {\"parts\" : \" functions,code\"}\n                \n        return dmda.domo_api_request(endpoint=endpoint, request_type = 'get', auth=auth,params=params, debug_api=debug_api)\n\n\n\nsource\n\n\nget_package_versions\n\n get_package_versions (auth:mbison.client.core.DomoAuth, package_id,\n                       debug_api:bool=False)\n\neach package can have one or many version\n\npackage = packages[1]\n\nget_package_version_by_id(\n    auth=auth, package_id=package[\"id\"], version=package[\"versions\"][0][\"version\"]\n)\n\n\npackage = packages[1]\n\nget_package_versions(\n    auth=auth, package_id=package[\"id\"])",
    "crumbs": [
      "feature",
      "CodeEngine"
    ]
  },
  {
    "objectID": "feature/codeengine.html#classes",
    "href": "feature/codeengine.html#classes",
    "title": "CodeEngine",
    "section": "Classes",
    "text": "Classes\n\nsource\n\nDomoCodeEngine_PackageVersion\n\n DomoCodeEngine_PackageVersion (auth:mbison.client.core.DomoAuth,\n                                package_id:str, version:str, code:str,\n                                created_by:dict,\n                                created_on_dt:datetime.datetime,\n                                updated_by:dict,\n                                updated_on_dt:datetime.datetime)\n\none package can have multiple versions\n\n\nExported source\n@dataclass \nclass DomoCodeEngine_PackageVersion:\n    \"\"\"one package can have multiple versions\"\"\"\n    \n    auth : dmda.DomoAuth = field(repr = False)\n    package_id: str\n    version : str\n    code : str\n    created_by : dict\n    created_on_dt : dt.datetime\n    updated_by : dict\n    updated_on_dt : dt.datetime\n\n    @classmethod\n    def from_json(cls, auth: dmda.DomoAuth, obj):\n        return cls(\n            auth = auth,\n            package_id = obj['packageId'],\n            version = obj['version'],\n            code = obj[\"code\"],\n            created_by = obj[\"createdBy\"],\n            created_on_dt = obj[\"createdOn\"],\n            updated_by = obj[\"updatedBy\"],\n            updated_on_dt = obj[\"updatedOn\"],\n        )\n    \n    @classmethod\n    def get_by_id(cls, auth : dmda.DomoAuth, package_id : str , version: str, return_raw : bool = False, debug_api: bool=  False):\n\n        res = get_package_version_by_id(auth = auth, package_id = package_id, \n                                  version = version, debug_api = debug_api)\n\n        if return_raw:\n            return res\n\n        return cls.from_json(\n            auth = auth,\n            obj = res.response\n        )\n\n\n\nDomoCodeEngine_PackageVersion.get_by_id(\n    auth=auth, \n    package_id=package[\"id\"],\n    version=package[\"versions\"][0][\"version\"]\n)\n\n\nsource\n\n\nDomoCodeEngine_Package\n\n DomoCodeEngine_Package (auth:mbison.client.core.DomoAuth, id:str,\n                         name:str, environment:str, availability:str,\n                         owner:dict, created_on_dt:datetime.datetime,\n                         updated_on_dt:datetime.datetime, source:str,\n                         current_version:str=None, description:str=None,\n                         language:str=None, dce_versions:List[__main__.Dom\n                         oCodeEngine_PackageVersion]=None, dce_current_ver\n                         sion:__main__.DomoCodeEngine_PackageVersion=None)\n\n\n\nExported source\n@dataclass\nclass DomoCodeEngine_Package:\n    auth: dmda.DomoAuth = field(repr=False)\n    id: str\n    name: str\n    environment: str\n    availability: str\n    owner: dict\n\n    created_on_dt: dt.datetime\n    updated_on_dt: dt.datetime\n\n    source: str\n\n    current_version: str = None\n    description: str = None\n    language: str = None\n\n    dce_versions: List[DomoCodeEngine_PackageVersion] = None\n    dce_current_version: DomoCodeEngine_PackageVersion = None\n\n    @classmethod\n    def from_json(cls, auth: dmda.DomoAuth, obj):\n\n        return cls(\n            auth=auth,\n            id=obj[\"id\"],\n            name=obj[\"name\"],\n            language=obj[\"language\"],\n            environment=obj[\"environment\"],\n            availability=obj[\"availability\"],\n            owner=obj[\"owner\"],\n            created_on_dt=obj[\"createdOn\"],\n            updated_on_dt=obj[\"updatedOn\"],\n            source=obj[\"packageSource\"],\n            description=obj.get(\"description\"),\n            current_version=obj.get(\"versions\")[0][\"version\"],\n        )\n\n    @classmethod\n    def get_by_id(\n        cls,\n        auth: dmda.DomoAuth,\n        package_id,\n        debug_api: bool = False,\n        return_raw: bool = False,\n    ):\n        res = get_package_by_id(auth=auth, package_id=package_id, debug_api=debug_api)\n\n        if return_raw:\n            return res\n\n        return cls.from_json(auth=auth, obj=res.response)\n\n    def get_versions(self, debug_api: bool = False, return_raw: bool = False):\n\n        res = get_package_versions(\n            auth=self.auth, package_id=self.id, debug_api=debug_api\n        )\n\n        if return_raw:\n            return res\n\n        self.dce_versions = [\n            DomoCodeEngine_PackageVersion.from_json(auth=self.auth, obj=obj)\n            for obj in res.response\n        ]\n\n        return self.dce_versions\n\n    def get_current_version(self, debug_api: bool = False, return_raw: bool = False):\n\n        res = DomoCodeEngine_PackageVersion.get_by_id(\n            auth=self.auth,\n            package_id=self.id,\n            version=self.current_version,\n            debug_api=debug_api,\n            return_raw=return_raw,\n        )\n\n        if return_raw:\n            return res\n\n        self.dce_current_version = res\n\n        return self.dce_current_version\n\n\n\npprint(DomoCodeEngine_Package.get_by_id(auth  =auth, package_id=package['id']))\n\n\nsource\n\n\nDomoCodeEngine_Packages\n\n DomoCodeEngine_Packages (auth:mbison.client.core.DomoAuth,\n                          packages:List[dict]=None, dce_packages:List[__ma\n                          in__.DomoCodeEngine_Package]=&lt;factory&gt;)\n\n\ndce_packages = DomoCodeEngine_Packages(auth = auth )\n\ndce_packages.get_packages()[0:5]",
    "crumbs": [
      "feature",
      "CodeEngine"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mbison",
    "section": "",
    "text": "This file will become your README and also the index of your documentation.",
    "crumbs": [
      "mbison"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "mbison",
    "section": "Install",
    "text": "Install\npip install mbison",
    "crumbs": [
      "mbison"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "mbison",
    "section": "How to use",
    "text": "How to use\n\nBase classes and routes for authentication, and dealing with api responses.\n\n\nclient.DomoAuth encapsulates authentication. Can init with username/password or access_token\nFor consistency, use client.domo_api_request to handle API requests in route functions. domo_api_requests and route functions should always return an instance of client.ResponseGetData class. For streaming responses, use client.domo_api_stream_request to automagically download API responses in route functions.\nRoute Functions should always throw an error if not ResponseGetData.is_success\n\nFeatures or classes are implemented as separate notebooks and then exported into their own module folder (see default_exp line in each .ipynb file) - each feature should be implemented as series of route functions (‘GET’, ‘PUT’, ‘POST’ requests), then a @dataclass class may be used to represent the feature with methods that wrap and provide logic around route functions. - ex. an UPSERT method might wrap logic to test if the entity already exists (in which case call the PUT route) or create the entity if it doesn’t already exist (‘POST’) - @classmethods return an instance of the class - ex. each class should have a get_by_id method which returns an instance of the entity (typically the result of the search datacenter API)\nImplementations, take a set of features and create a use case or project - ex.back up code engine and custom app (features) into appdb collections (feature)",
    "crumbs": [
      "mbison"
    ]
  },
  {
    "objectID": "client/utils.html",
    "href": "client/utils.html",
    "title": "utils",
    "section": "",
    "text": "source\n\nupsert_folder\n\n upsert_folder (folder_path:str, debug_prn:bool=False)\n\n\n\nExported source\ndef upsert_folder(folder_path: str, debug_prn: bool = False):\n    folder_path = os.path.dirname(folder_path)\n\n    if debug_prn:\n        print(\n            {\n                \"upsert_folder\": os.path.abspath(folder_path),\n                \"is_exist\": os.path.exists(folder_path),\n            }\n        )\n\n    if not os.path.exists(folder_path):\n        os.makedirs(folder_path)\n\n    return True\n\n\n\nsource\n\n\ndownload_zip\n\n download_zip (output_folder, zip_bytes_content:bytes=None,\n               zip_file_path:str=None)\n\nsave bytes content to a zip file then convert html to markdown\n\nsource\n\n\nchange_suffix\n\n change_suffix (filename, new_extension)\n\n\n\nCONVERT\n\nsource\n\nconvert_string_to_datetime\n\n convert_string_to_datetime (datestr:str)\n\n\n\nExported source\ndef convert_string_to_datetime(datestr: str) -&gt; dt.datetime:\n    if not datestr:\n        return None\n    return dateutil.parser.parse(datestr)",
    "crumbs": [
      "client",
      "utils"
    ]
  },
  {
    "objectID": "implementation/monitor_1_app.html",
    "href": "implementation/monitor_1_app.html",
    "title": "Monitoring Source Code Project",
    "section": "",
    "text": "auth = dmda.DomoAuth(\n    domo_instance=os.environ[\"DOMO_INSTANCE\"],\n    access_token=os.environ[\"DOMO_ACCESS_TOKEN\"],\n)\nauth\n\n\nsource\n\nDocumentSources\n\n DocumentSources (auth:mbison.client.core.DomoAuth,\n                  documents:List[__main__.DocumentSource]=&lt;factory&gt;,\n                  log_dt:datetime.datetime=datetime.datetime(2024, 7, 30,\n                  2, 0, 13, 812449))\n\n\n\nExported source\nclass SourceCode_Enum:\n    \"\"\"captures metadata about where source came from\"\"\"\n    CODE_ENGINE = \"Code Engine\"\n    ENTERPRISE_APP = \"Enterprise App\"\n\n\n@dataclass\nclass DocumentSource:\n    environment: SourceCode_Enum\n    id: str\n    name: str\n    design_id: str\n    design_name: str\n    log_dt: dt.datetime\n    code: str\n    version: str\n    last_modified_dt: dt.datetime\n    domo_instance: str\n    owner: str\n\n    def __eq__(self, other):\n        if not self.__class__.__name__ == other.__class__.__name__:\n            return False\n\n        return self.id == other.id and self.environment == other.environment\n\n    @classmethod\n    def from_codeengine_package_version(\n        cls, dce_package: dmce.DomoCodeEngine_Package, log_dt: dt.datetime = None\n    ):\n\n        log_dt = log_dt or dt.datetime.now()\n\n        dce_current_version = dce_package.get_current_version()\n\n        # from pprint import pprint\n        # pprint({\"version\": dce_current_version,\n        #        \"owner\" : dce_package.owner})\n\n        owner = None\n        try:\n            owner = dmdu.DomoUser.get_by_id(\n                auth=dce_package.auth, user_id=dce_package.owner\n            )\n\n        except dmdu.User_API_Exception as e:\n            print(e)\n\n        return cls(\n            environment=SourceCode_Enum.CODE_ENGINE,\n            id=dce_package.id,\n            name=dce_package.name,\n            design_id=dce_package.id,\n            design_name=dce_package.name,\n            log_dt=log_dt,\n            code=dce_current_version.code,\n            version=dce_current_version.version,\n            last_modified_dt=dce_package.updated_on_dt,\n            domo_instance=dce_package.auth.domo_instance,\n            owner=owner,\n        )\n\n    @classmethod\n    def from_source_file(\n        cls,\n        file_path,\n        design_id,\n        design_name,\n        domo_instance: str,\n        owner: dmdu.DomoUser,\n        log_dt: dt.datetime = None,\n        version: str = None,\n        last_modified_dt: dt.datetime = None,\n    ):\n\n        with open(file_path, \"r\") as f:\n            code = f.read()\n\n        log_dt = log_dt or dt.datetime.now()\n\n        return cls(\n            id=file_path,\n            name=os.path.split(file_path)[-1],\n            design_id=design_id,\n            design_name=design_name,\n            log_dt=log_dt,\n            code=code,\n            version=version,\n            last_modified_dt=last_modified_dt,\n            domo_instance=domo_instance,\n            owner=owner,\n            environment=SourceCode_Enum.ENTERPRISE_APP,\n        )\n\n        # custom_app, design_version, appdb_collection):\n        # document[\"ID\"] = custom_app[\"id\"]\n        # document[\"Name\"] = custom_app[\"name\"]\n        # document[\"Published Date\"] = custom_app[\"updatedDate\"]\n\n\n@dataclass\nclass DocumentSources:\n    auth: dmda.DomoAuth\n    documents: List[DocumentSource] = field(default_factory=lambda: [])\n\n    log_dt: dt.datetime = dt.datetime.now()\n\n    def get_codeengine(self):\n        domo_codenegine_packages = dmce.DomoCodeEngine_Packages(\n            auth=self.auth\n        ).get_packages()\n\n        documents = [\n            DocumentSource.from_codeengine_package_version(\n                dce_package=dce_package, log_dt=self.log_dt\n            )\n            for dce_package in domo_codenegine_packages\n        ]\n\n        [self.add_document(document) for document in documents]\n\n        return self.documents\n\n    @staticmethod\n    def _download_custom_app_sourcecode(app, download_folder, debug_api: bool = False):\n            zip_name = \"_package.zip\"\n            _download_folder = f\"{download_folder}/{app.name}/{app.current_version}\"\n\n            try:\n                res = app.get_source_code(download_folder=_download_folder, file_name=zip_name, debug_api = debug_api)\n                \n                zip_file_path=os.path.join(\n                        _download_folder, zip_name\n                    )\n                \n                path_ls = dmut.download_zip(\n                    output_folder=_download_folder,\n                    zip_file_path=zip_file_path,\n                )\n\n                res.response = path_ls\n\n                return res\n            \n            except dmap.App_API_Exception as e:\n                print(e)\n                return False\n\n\n    def get_custom_apps(self, download_folder=\"./EXPORT\", debug_api : bool = False):\n        domo_apps = dmap.DomoEnterpriseApps(auth=self.auth).get_apps()\n\n        return [self._download_custom_app_sourcecode(app = app, download_folder = download_folder, debug_api = debug_api) for app in domo_apps]            \n\n\n    def add_document(self, document: DocumentSource):\n        if document in self.documents:\n            return False\n\n        self.documents.append(document)\n        return True\n\n\n\nsource\n\n\nDocumentSource\n\n DocumentSource (environment:__main__.SourceCode_Enum, id:str, name:str,\n                 design_id:str, design_name:str, log_dt:datetime.datetime,\n                 code:str, version:str,\n                 last_modified_dt:datetime.datetime, domo_instance:str,\n                 owner:str)\n\n\nsource\n\n\nSourceCode_Enum\n\n SourceCode_Enum ()\n\ncaptures metadata about where source came from\n\ndocument_sources = DocumentSources(auth= auth)\n\nres_ls = document_sources.get_custom_apps(download_folder= '../../TEST/' ,debug_api = False)\n[res for res in res_ls if res ][0:5]\n\n\ndocument_sources = DocumentSources(auth= auth)\n\ndocument_sources.get_codeengine()\n\n\ndocument_sources.documents[0]\n\n\ndocument_sources.documents[0].__dict__",
    "crumbs": [
      "implementation",
      "Monitoring Source Code Project"
    ]
  },
  {
    "objectID": "implementation/monitoring.html",
    "href": "implementation/monitoring.html",
    "title": "Monitoring Source Code Project",
    "section": "",
    "text": "auth = dmda.DomoAuth(\n    domo_instance=os.environ[\"DOMO_INSTANCE\"],\n    access_token=os.environ[\"DOMO_ACCESS_TOKEN\"],\n)\nauth\n\n\nsource\n\nDocumentSources\n\n DocumentSources (auth:mbison.client.core.DomoAuth,\n                  documents:List[__main__.DocumentSource]=&lt;factory&gt;,\n                  log_dt:datetime.datetime=datetime.datetime(2024, 7, 30,\n                  2, 0, 13, 827619))\n\n\n\nExported source\nclass SourceCode_Enum:\n    \"\"\"captures metadata about where source came from\"\"\"\n    CODE_ENGINE = \"Code Engine\"\n    ENTERPRISE_APP = \"Enterprise App\"\n\n\n@dataclass\nclass DocumentSource:\n    environment: SourceCode_Enum\n    id: str\n    name: str\n    design_id: str\n    design_name: str\n    log_dt: dt.datetime\n    code: str\n    version: str\n    last_modified_dt: dt.datetime\n    domo_instance: str\n    owner: str\n\n    def __eq__(self, other):\n        if not self.__class__.__name__ == other.__class__.__name__:\n            return False\n\n        return self.id == other.id and self.environment == other.environment\n\n    @classmethod\n    def from_codeengine_package_version(\n        cls, dce_package: dmce.DomoCodeEngine_Package, log_dt: dt.datetime = None\n    ):\n\n        log_dt = log_dt or dt.datetime.now()\n\n        dce_current_version = dce_package.get_current_version()\n\n        # from pprint import pprint\n        # pprint({\"version\": dce_current_version,\n        #        \"owner\" : dce_package.owner})\n\n        owner = None\n        try:\n            owner = dmdu.DomoUser.get_by_id(\n                auth=dce_package.auth, user_id=dce_package.owner\n            )\n\n        except dmdu.User_API_Exception as e:\n            print(e)\n\n        return cls(\n            environment=SourceCode_Enum.CODE_ENGINE,\n            id=dce_package.id,\n            name=dce_package.name,\n            design_id=dce_package.id,\n            design_name=dce_package.name,\n            log_dt=log_dt,\n            code=dce_current_version.code,\n            version=dce_current_version.version,\n            last_modified_dt=dce_package.updated_on_dt,\n            domo_instance=dce_package.auth.domo_instance,\n            owner=owner,\n        )\n\n    @classmethod\n    def from_source_file(\n        cls,\n        file_path,\n        design_id,\n        design_name,\n        domo_instance: str,\n        owner: dmdu.DomoUser,\n        log_dt: dt.datetime = None,\n        version: str = None,\n        last_modified_dt: dt.datetime = None,\n    ):\n\n        with open(file_path, \"r\") as f:\n            code = f.read()\n\n        log_dt = log_dt or dt.datetime.now()\n\n        return cls(\n            id=file_path,\n            name=os.path.split(file_path)[-1],\n            design_id=design_id,\n            design_name=design_name,\n            log_dt=log_dt,\n            code=code,\n            version=version,\n            last_modified_dt=last_modified_dt,\n            domo_instance=domo_instance,\n            owner=owner,\n            environment=SourceCode_Enum.ENTERPRISE_APP,\n        )\n\n        # custom_app, design_version, appdb_collection):\n        # document[\"ID\"] = custom_app[\"id\"]\n        # document[\"Name\"] = custom_app[\"name\"]\n        # document[\"Published Date\"] = custom_app[\"updatedDate\"]\n\n\n@dataclass\nclass DocumentSources:\n    auth: dmda.DomoAuth\n    documents: List[DocumentSource] = field(default_factory=lambda: [])\n\n    log_dt: dt.datetime = dt.datetime.now()\n\n    def get_codeengine(self):\n        domo_codenegine_packages = dmce.DomoCodeEngine_Packages(\n            auth=self.auth\n        ).get_packages()\n\n        documents = [\n            DocumentSource.from_codeengine_package_version(\n                dce_package=dce_package, log_dt=self.log_dt\n            )\n            for dce_package in domo_codenegine_packages\n        ]\n\n        [self.add_document(document) for document in documents]\n\n        return self.documents\n\n    @staticmethod\n    def _download_custom_app_sourcecode(app, download_folder, debug_api: bool = False):\n            zip_name = \"_package.zip\"\n            _download_folder = f\"{download_folder}/{app.name}/{app.current_version}\"\n\n            try:\n                res = app.get_source_code(download_folder=_download_folder, file_name=zip_name, debug_api = debug_api)\n                \n                zip_file_path=os.path.join(\n                        _download_folder, zip_name\n                    )\n                \n                path_ls = dmut.download_zip(\n                    output_folder=_download_folder,\n                    zip_file_path=zip_file_path,\n                )\n\n                res.response = path_ls\n\n                return res\n            \n            except dmap.App_API_Exception as e:\n                print(e)\n                return False\n\n\n    def get_custom_apps(self, download_folder=\"./EXPORT\", debug_api : bool = False):\n        domo_apps = dmap.DomoEnterpriseApps(auth=self.auth).get_apps()\n\n        return [self._download_custom_app_sourcecode(app = app, download_folder = download_folder, debug_api = debug_api) for app in domo_apps]            \n\n\n    def add_document(self, document: DocumentSource):\n        if document in self.documents:\n            return False\n\n        self.documents.append(document)\n        return True\n\n\n\nsource\n\n\nDocumentSource\n\n DocumentSource (environment:__main__.SourceCode_Enum, id:str, name:str,\n                 design_id:str, design_name:str, log_dt:datetime.datetime,\n                 code:str, version:str,\n                 last_modified_dt:datetime.datetime, domo_instance:str,\n                 owner:str)\n\n\nsource\n\n\nSourceCode_Enum\n\n SourceCode_Enum ()\n\ncaptures metadata about where source came from\n\ndocument_sources = DocumentSources(auth= auth)\n\nres_ls = document_sources.get_custom_apps(download_folder= '../../TEST/' ,debug_api = False)\n[res for res in res_ls if res ][0:5]\n\n\ndocument_sources = DocumentSources(auth= auth)\n\ndocument_sources.get_codeengine()\n\n\ndocument_sources.documents[0]\n\n\ndocument_sources.documents[0].__dict__",
    "crumbs": [
      "implementation",
      "Monitoring Source Code Project"
    ]
  },
  {
    "objectID": "client/core.html",
    "href": "client/core.html",
    "title": "Core",
    "section": "",
    "text": "Base classes and routes for authentication, and dealing with api responses.\nFeatures or classes are implemented as separate notebooks and then exported into their own module folder (see default_exp line in each .ipynb file)\nImplementations, take a set of features and create a use case or project - ex.back up code engine and custom app (features) into appdb collections (feature)\nsource",
    "crumbs": [
      "client",
      "Core"
    ]
  },
  {
    "objectID": "client/core.html#handling-authentication",
    "href": "client/core.html#handling-authentication",
    "title": "Core",
    "section": "handling authentication",
    "text": "handling authentication\n\nsource\n\nDomoAuth\n\n DomoAuth (domo_instance:str, username:str=None, password:str=None,\n           access_token:str=None, session_token:str=None)\n\n\n\nExported source\n@dataclass\nclass DomoAuth:\n    domo_instance: str\n\n    username: str = None\n    password: str = field(repr=False, default=None)\n    access_token: str = field(repr=False, default=None)\n    session_token: str = field(repr=False, default=None)\n\n    @classmethod\n    def from_creds_json(\n        cls,\n        creds_json: dict,\n    ):\n        username = creds_json.get(\"DOMO_USERNAME\")\n        password = creds_json.get(\"DOMO_PASSWORD\")\n\n        access_token = creds_json.get(\"accessToken\") or creds_json.get(\"ACCESS_TOKEN\")\n\n        domo_instance = creds_json.get(\"instance_url\")\n\n        if username and password:\n            return cls(\n                username=username,\n                password=password,\n                access_token=access_token,\n                domo_instance=domo_instance,\n            )\n\n    def generate_request_headers(self):\n        headers = {\n            \"Accept\": \"application/json\",\n            \"Content-Type\": \"application/json\",\n        }\n\n        if self.session_token:\n            headers.update({\"x-domo-authentication\": self.session_token})\n            return headers\n\n        if self.access_token:\n            headers.update({\"x-domo-developer-token\": self.access_token})\n            return headers\n\n        raise Exception(\n            \"generate_request_headers: unable to authenticate request with provided Auth\"\n        )\n\n    def who_am_i(self, return_raw: bool = False):\n        \"\"\"identify which credentials are being used in this Auth Object (useful for access_token based authentication)\"\"\"\n\n        url = f\"https://{self.domo_instance}.domo.com/api/content/v2/users/me\"\n\n        res = json.loads(\n            requests.request(\n                method=\"GET\", headers=self.generate_request_headers(), url=url\n            ).text\n        )\n\n        if return_raw:\n            return res\n\n        self.username = res[\"emailAddress\"]\n\n        return res\n\n\n\nsample DomoAuth\n\nauth = DomoAuth(\n    domo_instance=os.environ[\"DOMO_INSTANCE\"],\n    access_token=os.environ[\"DOMO_ACCESS_TOKEN\"],\n)\n\nprint(auth.who_am_i(return_raw=False))\nauth\n\n{'id': 1893952720, 'invitorUserId': 587894148, 'displayName': 'Jae Wilson1', 'department': 'Business Improvement', 'userName': 'jae@onyxreporting.com', 'emailAddress': 'jae@datacrew.space', 'avatarKey': 'c605f478-0cd2-4451-9fd4-d82090b71e66', 'accepted': True, 'userType': 'USER', 'modified': 1721847526952, 'created': 1588960518, 'active': True, 'pending': False, 'anonymous': False, 'systemUser': False}\n\n\nDomoAuth(domo_instance='domo-community', username='jae@datacrew.space')",
    "crumbs": [
      "client",
      "Core"
    ]
  },
  {
    "objectID": "client/core.html#sending-requests",
    "href": "client/core.html#sending-requests",
    "title": "Core",
    "section": "sending requests",
    "text": "sending requests\n\nsource\n\nResponseGetData\n\n ResponseGetData (auth:__main__.DomoAuth, response:dict, is_success:bool,\n                  status:int, download_path:str=None)\n\n\n\nExported source\nclass API_Exception(Exception):\n\n    def __init__(self, res, message: str = None):\n        message = message or \"\"\n        base = f\" || {str(res.status)} - {res.response.get('message') or res.response.get('statusReason')} || {res.auth.domo_instance}\"\n        message += base\n\n        super().__init__(message)\n\n\nclass Class_Exception(Exception):\n\n    def __init__(self, cls, auth=None, message: str = None):\n        cls_instance = cls\n\n        if hasattr(cls, \"__cls__\"):\n            cls_instance = cls\n            cls = cls.__cls__\n\n        domo_instance = {\n            (cls_instance and cls_instance.auth.domo_instance)\n            or (auth and auth.domo_instance)\n        }\n\n        message = f\"{message or 'error'} || {cls.__name__}\"\n\n        if domo_instance:\n            message = f\"{message} || {domo_instance}\"\n\n        super().__init__(message)\n\n\n@dataclass\nclass ResponseGetData:\n    auth: DomoAuth = field(repr=False)\n    response: dict\n    is_success: bool\n    status: int\n    download_path: str = None\n\n    @classmethod\n    def from_response(cls, res, auth: DomoAuth):\n\n        try:\n            if res.text == \"\" or not res.text:\n                return cls(\n                    response=res.text,\n                    is_success=res.ok,\n                    status=res.status_code,\n                    auth=auth,\n                )\n\n            return cls(\n                response=json.loads(res.text),\n                is_success=res.ok,\n                status=res.status_code,\n                auth=auth,\n            )\n\n        except Exception as e:\n            print({\"rgd.from_response\": {\"text\": res.text, \"err\": e}})\n\n            raise e\n\n    @staticmethod\n    def _write_stream(res: requests.Response, file_path: str, stream_chunks=8192):\n\n        dmut.upsert_folder(file_path)\n\n        with open(file_path, \"wb\") as fd:\n            for chunk in res.iter_content(stream_chunks):\n                fd.write(chunk)\n\n        print(\"done writing stream\")\n        return True\n\n    @staticmethod\n    def read_stream(download_path):\n        with open(download_path, \"rb\") as f:\n            return f.read()\n\n    @classmethod\n    def from_stream(cls, res: requests.Response, download_path: str, auth: DomoAuth):\n\n        if not res.ok:\n            return cls.from_response(res=res, auth=auth)\n\n        cls._write_stream(res, download_path)\n\n        return cls(\n            response=True if cls.read_stream(download_path) else False,\n            is_success=res.ok,\n            status=res.status_code,\n            auth=auth,\n            download_path=download_path,\n        )\n\n\n\nsource\n\n\nClass_Exception\n\n Class_Exception (cls, auth=None, message:str=None)\n\nCommon base class for all non-exit exceptions.\n\nsource\n\n\nAPI_Exception\n\n API_Exception (res, message:str=None)\n\nCommon base class for all non-exit exceptions.\n\nsource\n\n\ndomo_api_request\n\n domo_api_request (auth:__main__.DomoAuth, endpoint, request_type,\n                   params=None, headers=None, body=None,\n                   return_raw:bool=False, debug_api:bool=False, timeout=3)\n\n\n\nExported source\ndef domo_api_request(\n    auth: DomoAuth,\n    endpoint,\n    request_type,\n    params=None,\n    headers=None,\n    body=None,\n    return_raw: bool = False,\n    debug_api: bool = False,\n    timeout=3,\n):\n\n    url = f\"https://{auth.domo_instance}.domo.com{endpoint}\"\n\n    headers = headers or {}\n\n    headers = {**auth.generate_request_headers(), **headers}\n\n    if debug_api:\n\n        print(\"🐛 debugging domo_api_request\")\n        pprint(\n            {\n                \"url\": url,\n                \"headers\": headers,\n                \"request_type\": request_type,\n                \"params\": params,\n                \"body\": body,\n            }\n        )\n\n    if request_type.lower() == \"post\":\n        response = requests.post(\n            url, json=body, headers=headers, params=params, timeout=timeout\n        )\n\n    elif request_type.lower() == \"get\":\n        response = requests.get(url, headers=headers, params=params, timeout=timeout)\n\n    else:\n        raise Exception(\n            f'domo_api_request method \"{request_type.lower()}\" not implemented yet.'\n        )\n\n    if return_raw:\n        return response\n\n    return ResponseGetData.from_response(res=response, auth=auth)\n\n\n\nsource\n\n\nlooper\n\n looper (auth:__main__.DomoAuth, arr_fn:Callable, endpoint:str,\n         request_type='GET', params:dict=None, body:dict=None, offset=0,\n         limit=50, offset_params:dict=None,\n         offset_params_is_header:bool=False, debug_api:bool=False,\n         debug_loop:bool=False, return_raw:bool=False)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nauth\nDomoAuth\n\n\n\n\narr_fn\nCallable\n\n\n\n\nendpoint\nstr\n\n\n\n\nrequest_type\nstr\nGET\n\n\n\nparams\ndict\nNone\n\n\n\nbody\ndict\nNone\n\n\n\noffset\nint\n0\n\n\n\nlimit\nint\n50\n\n\n\noffset_params\ndict\nNone\nformat {“offset” : &lt;&gt; , “limit” : &lt;&gt;}\n\n\noffset_params_is_header\nbool\nFalse\nshould offset parameters be passed in the header or body?\n\n\ndebug_api\nbool\nFalse\n\n\n\ndebug_loop\nbool\nFalse\n\n\n\nreturn_raw\nbool\nFalse\nwill break the looper after the first request and ignore the array processing step.\n\n\n\n\n\nExported source\nlooper_offset_params = {\n    \"offset\": \"offset\",\n    \"limit\": \"limit\",\n}  # what are the offset parameters called that handle pagination?\n\n\ndef looper(\n    auth: DomoAuth,\n    arr_fn: Callable,\n    endpoint: str,\n    request_type=\"GET\",\n    params: dict = None,\n    body: dict = None,\n    offset=0,\n    limit=50,\n    offset_params: dict = None,  # format {\"offset\" : &lt;&lt;value&gt;&gt; , \"limit\" : &lt;&lt;value&gt;&gt;}\n    offset_params_is_header: bool = False,  # should offset parameters be passed in the header or body?\n    debug_api: bool = False,\n    debug_loop: bool = False,\n    return_raw: bool = False,  # will break the looper after the first request and ignore the array processing step.\n):\n    params = params or {}\n    body = body or {}\n    offset_params = offset_params or looper_offset_params\n\n    final_array = []\n    keep_looping = True\n\n    while keep_looping:\n        new_offset = {\n            offset_params[\"offset\"]: offset,\n            offset_params[\"limit\"]: limit,\n        }\n        if offset_params_is_header:\n            params = deepcopy({**params, **new_offset})\n\n        else:\n            body = {**body, **new_offset}\n\n        res = domo_api_request(\n            auth=auth,\n            endpoint=endpoint,\n            request_type=request_type,\n            params=params,\n            debug_api=debug_api,\n            body=body,\n        )\n\n        if res.status == 429:\n            print(\"sleeping in timeout\")\n            time.sleep(10)\n            debug_loop = True\n            keep_looping = True\n\n        elif not res.is_success or return_raw:\n            return res\n\n        else:\n            new_array = arr_fn(res)\n\n            if debug_loop:\n                pprint(\"🔁 debug_loop\")\n                pprint(\n                    {\n                        \"params\": params,\n                        \"body\": body,\n                        # \"new_array\": new_array[0:1]\n                    }\n                )\n\n            if not new_array or len(new_array) == 0:\n                keep_looping = False\n\n            if len(new_array) &lt; limit:\n                keep_looping = False\n\n            final_array += new_array\n\n            offset += limit\n\n    res.response = final_array\n\n    return res\n\n\n\nsource\n\n\ndomo_api_stream_request\n\n domo_api_stream_request (auth:__main__.DomoAuth, endpoint, request_type,\n                          download_path, params=None, headers=None,\n                          debug_api:bool=False, timeout=3)\n\n\n\nExported source\ndef domo_api_stream_request(\n    auth: DomoAuth,\n    endpoint,\n    request_type,\n    download_path,\n    params=None,\n    headers=None,\n    debug_api: bool = False,\n    timeout=3,\n):\n\n    url = f\"https://{auth.domo_instance}.domo.com{endpoint}\"\n\n    headers = headers or {}\n\n    headers = {**auth.generate_request_headers(), **headers}\n\n    if debug_api:\n\n        print(\"debugging domo_api_request\")\n\n        pprint(\n            {\n                \"url\": url,\n                \"headers\": headers,\n                \"request_type\": request_type,\n                \"params\": params,\n            }\n        )\n\n    res = requests.get(\n        url=url, headers=headers, params=params, timeout=timeout, stream=True\n    )\n\n    if not res.ok:\n        return ResponseGetData.from_response(res=res, auth=auth)\n\n    return ResponseGetData.from_stream(res=res, download_path=download_path, auth=auth)",
    "crumbs": [
      "client",
      "Core"
    ]
  },
  {
    "objectID": "feature/cards.html",
    "href": "feature/cards.html",
    "title": "cards",
    "section": "",
    "text": "auth = dmda.DomoAuth(\n    domo_instance=os.environ[\"DOMO_INSTANCE\"],\n    access_token=os.environ[\"DOMO_ACCESS_TOKEN\"],\n)\nauth\n\nDomoAuth(domo_instance='domo-community', username=None)",
    "crumbs": [
      "feature",
      "cards"
    ]
  },
  {
    "objectID": "feature/cards.html#routes",
    "href": "feature/cards.html#routes",
    "title": "cards",
    "section": "Routes",
    "text": "Routes\n\ncard_id = '577316875'\n\n\nsource\n\nCards_API_Exception\n\n Cards_API_Exception (res, message=None)\n\nCommon base class for all non-exit exceptions.\n\n\nExported source\nclass Cards_API_Exception(dmda.API_Exception):\n    def __init__(self, res, message=None):\n\n        super().__init__(res=res, message=message)\n\n\n\nsource\n\n\nsearch_cards\n\n search_cards (auth:mbison.client.core.DomoAuth, query:dict=None,\n               debug_api:bool=False, return_raw:bool=False,\n               debug_loop:bool=False, limit:int=100, offset:int=0)\n\n\n\nExported source\ndef generate_search_cards_only_apps_filter():\n    return {\n        \"includeCardTypeClause\": True,\n        \"cardTypes\": [\"domoapp\", \"mason\", \"custom\"],\n        \"ascending\": True,\n        \"orderBy\": \"cardTitle\",\n    }\n\ndef search_cards(\n    auth: dmda.DomoAuth,\n    query: dict = None,\n    debug_api: bool = False,\n    return_raw: bool = False,\n    debug_loop: bool = False,\n    limit: int = 100,\n    offset: int = 0,\n):\n\n    endpoint = \"/api/content/v2/cards/adminsummary\"\n    query = query or {}\n    \n\n\n    def arr_fn(res):\n        if res.status == 429:\n            return []\n        \n        return res.response.get(\"cardAdminSummaries\", [])\n    \n    res = dmda.looper(\n        auth=auth,\n        arr_fn=arr_fn,\n        offset_params={\"limit\": \"limit\", \"offset\": \"skip\"},\n        offset_params_is_header=True,\n\n        request_type=\"POST\",\n        endpoint=endpoint,\n\n        debug_api=debug_api,\n        return_raw=return_raw,\n        debug_loop=debug_loop, \n\n        # params = params\n\n        body=query,\n        limit=limit,\n        offset=offset,\n\n    )\n\n    if not res.is_success:\n        print(res)\n        raise Cards_API_Exception(res=res)\n\n    return res\n\n\n\nsource\n\n\ngenerate_search_cards_only_apps_filter\n\n generate_search_cards_only_apps_filter ()\n\n\nquery = generate_search_cards_only_apps_filter()\n\nres = search_cards(\n    auth=auth,\n    query=query,\n    return_raw=False,\n    debug_loop=False,\n    debug_api=False,\n    offset = 0)\n\ncards =res.response\n\nprint(len(cards))\ncards[0:1]\n\n191\n\n\n[{'owners': [{'id': '1728973208',\n    'type': 'USER',\n    'displayName': 'Peter Shull'}],\n  'id': 528432108,\n  'type': 'domoapp',\n  'badgeUpdated': 1711677072000,\n  'title': '100 People',\n  'locked': False,\n  'pageHierarchy': [{'pageId': 682992709, 'title': 'LLM Testing'}]}]\n\n\n\nsource\n\n\nget_card_by_id\n\n get_card_by_id (card_id, auth:mbison.client.core.DomoAuth, optional_parts\n                 ='certification,datasources,drillPath,owners,properties,d\n                 omoapp', debug_api:bool=False, return_raw:bool=False)\n\n\n\nExported source\noptional_parts = [\n    \"certification\",\n    \"datasources\",\n    \"domoapp\",\n    \"drillPath\",\n    \"masonData\",\n    \"metadata\",\n    \"owners\",\n    \"problems\",\n    \"properties\",\n]\n\n\ndef get_card_by_id(card_id, auth: dmda.DomoAuth, optional_parts = 'certification,datasources,drillPath,owners,properties,domoapp', debug_api: bool = False, return_raw: bool = False):\n    endpoint = \"/api/content/v1/cards/\"\n\n    params = {\"parts\": optional_parts, \"urns\": card_id}\n\n    res = dmda.domo_api_request(\n\n        auth=auth,\n\n        request_type=\"GET\",\n        endpoint=endpoint,\n\n        debug_api=debug_api,\n        params=params,\n\n    )\n\n    if not res.is_success:\n        raise Cards_API_Exception(res=res)\n    \n    if return_raw:\n        return res\n    \n    res.response = res.response[0]\n    \n\n    return res\n\n\n\ncard= (get_card_by_id(card_id=cards[0]['id'], auth = auth)).response\ncard\n\n{'domoapp': {'id': 'aace1266-dc7f-42cb-8595-46069d91a703'},\n 'drillPath': {},\n 'owners': [{'id': '1728973208',\n   'type': 'USER',\n   'displayName': 'Peter Shull'}],\n 'datasources': [{'dataSourceId': 'b995e5ba-b1cc-4dff-89f7-d8949c0d0aad',\n   'dataSourceName': 'Example Sales Data',\n   'displayType': 'webform',\n   'dataType': 'webform',\n   'providerType': 'webform',\n   'isSampleData': False,\n   'lastUpdated': 1711668314801,\n   'adc': False,\n   'phase': None,\n   'state': 'SUCCESS'},\n  {'dataSourceId': '2b0016a7-02bd-45b4-a9fe-b33fbf5b365e',\n   'dataSourceName': '100people',\n   'displayType': 'large-file-upload',\n   'dataType': 'large-file-upload',\n   'providerType': 'large-file-upload',\n   'isSampleData': False,\n   'lastUpdated': 1711674871363,\n   'adc': False,\n   'phase': None,\n   'state': 'SUCCESS'}],\n 'certification': {'state': 'NOT_CERTIFIED', 'adminCertified': False},\n 'urn': '528432108',\n 'id': 528432108,\n 'type': 'domoapp',\n 'created': 1711668314,\n 'badgeUpdated': 1711677072000,\n 'creatorId': 1728973208,\n 'ownerId': 1728973208,\n 'title': '100 People',\n 'active': True,\n 'allowTableDrill': True,\n 'locked': False,\n 'isCurrentUserOwner': False}\n\n\n\n\nclasses\n\nsource\n\n\nDomoCard\n\n DomoCard (id:str, auth:mbison.client.core.DomoAuth, title:str=None,\n           description:str=None, type:str=None, urn:str=None,\n           chart_type:str=None, dataset_id:str=None,\n           datastore_id:str=None, domo_collections:List[Any]=None,\n           domo_source_code:Any=None, owners:List[&lt;built-\n           infunctionany&gt;]=None)\n\n\n\nExported source\n@dataclass\nclass DomoCard:\n    id: str\n    auth: dmda.DomoAuth = field(repr=False)\n    title: str = None\n    description: str = None\n    type: str = None\n    urn: str = None\n    chart_type: str = None\n    dataset_id: str = None\n\n    datastore_id : str = None\n    \n    domo_collections: List[Any] = None\n    domo_source_code : Any = None\n\n    owners: List[any] = None\n\n    def display_url(self) -&gt; str:\n        return f\"https://{self.auth.domo_instance}.domo.com/kpis/details/{self.id}\"\n    \n\n    @classmethod\n    def _from_json(cls, obj : dict, auth: dmda.DomoAuth):\n\n        card = cls(\n            auth=auth,\n            id=obj['id'],\n            title=obj['title'],\n            type= obj['type'],\n            urn= obj['urn'],\n            description= obj.get('description'),\n            owners = obj.get('owners')\n        )\n\n        if obj.get('domoapp',{}).get('id'):\n            card.datastore_id = obj['domoapp']['id']\n    \n        return card\n\n    @classmethod\n    def get_by_id(\n        cls,\n        card_id: str,\n        auth: dmda.DomoAuth,\n        debug_api: bool = False,\n        return_raw: bool = False\n    ):\n        res = get_card_by_id(\n            auth=auth,\n            card_id=card_id, \n            debug_api=debug_api\n        )\n\n        if return_raw:\n            return res\n\n\n        return cls._from_json(res.response, auth)\n\n\n\nDomoCard.get_by_id(\n    card_id=355758291,\n    auth = auth,\n    return_raw = False\n)\n\nDomoCard(id=355758291, title='Phoenix Stacked Bar Chart Brick', description=None, type='domoapp', urn='355758291', chart_type=None, dataset_id=None, datastore_id='be4d8af8-b48f-4ae8-ab5f-f010dcfd865f', domo_collections=None, domo_source_code=None, owners=[{'id': '1334846498', 'type': 'USER', 'displayName': 'Jonathan Pilafas'}])\n\n\n\nsource\n\n\nDomoCard.get_source_code\n\n DomoCard.get_source_code (debug_api:bool=False)\n\n\n\nExported source\n@patch_to(DomoCard)\ndef get_collections(self, debug_api : bool = False, return_raw: bool = False):\n    import mbison.feature.appdb as dmdb\n    \n    res  = dmdb.get_collections(datastore_id= self.datastore_id, auth = auth, debug_api= debug_api)\n\n    if return_raw:\n        return res\n\n    self.domo_collections = [ dmdb.AppDbCollection.get_by_id(collection_id = obj['id'], auth = auth, debug_api = debug_api) for obj in res.response]\n\n    return self.domo_collections\n\n\n@patch_to(DomoCard)\ndef get_source_code(self, debug_api : bool = False):\n    self.get_collections(debug_api = debug_api)\n\n    collection_name = 'ddx_app_client_code'\n    code_collection = next((domo_collection for domo_collection in self.domo_collections if domo_collection.name ==collection_name), None)\n\n    if not code_collection:\n        raise dmda.Class_Exception(cls = self, message = f\"collection - {collection_name} not found\")\n    \n    self.domo_source_code = code_collection.query_documents(debug_api = debug_api)[0]\n\n    return self.domo_source_code\n\n\n\nsource\n\n\nDomoCard.get_collections\n\n DomoCard.get_collections (debug_api:bool=False, return_raw:bool=False)\n\n\ndomo_card = DomoCard.get_by_id(\n    card_id=577316875,\n    auth = auth,\n    return_raw = False\n)\n\ndomo_source_code_document = domo_card.get_source_code()\npprint(domo_source_code_document.content)\n\n{'htmlBlank': {'css': '',\n               'html': '',\n               'js': '// DDX Bricks Wiki - See '\n                     'https://developer.domo.com/docs/ddx-bricks/getting-started-using-ddx-bricks\\n'\n                     '// for tips on getting started, linking to Domo data and '\n                     'debugging your app\\n'\n                     ' \\n'\n                     '//Available globals\\n'\n                     'var domo = window.domo; // For more on domo.js: '\n                     'https://developer.domo.com/docs/dev-studio-guides/domo-js#domo.get\\n'\n                     'var datasets = window.datasets;\\n'\n                     '\\n'\n                     '//Step 1. Select your dataset(s) from the button in the '\n                     'bottom left corner\\n'\n                     '\\n'\n                     '\\n'\n                     '\\n'\n                     '//Step 2. Query your dataset(s): '\n                     'https://developer.domo.com/docs/dev-studio-references/data-api\\n'\n                     \"var fields = ['state', 'revenue'];\\n\"\n                     \"var groupby = ['state'];\\n\"\n                     'var query = '\n                     '`/data/v1/${datasets[0]}?fields=${fields.join()}&groupby=${groupby.join()}`;\\n'\n                     'domo.get(query).then(handleResult);\\n'\n                     '\\n'\n                     '\\n'\n                     '\\n'\n                     '//Step 3. Do something with the data from the query '\n                     'result\\n'\n                     'function handleResult(data){\\n'\n                     '  console && console.log(data);\\n'\n                     '}'}}",
    "crumbs": [
      "feature",
      "cards"
    ]
  },
  {
    "objectID": "feature/appdb.html",
    "href": "feature/appdb.html",
    "title": "appdb",
    "section": "",
    "text": "auth = dmda.DomoAuth(\n    domo_instance=os.environ[\"DOMO_INSTANCE\"],\n    access_token=os.environ[\"DOMO_ACCESS_TOKEN\"],\n)\nauth\n\nDomoAuth(domo_instance='domo-community', username=None)\ncollection_id = '0f68f250-df2c-4a15-98ef-9cdd851602eb'",
    "crumbs": [
      "feature",
      "appdb"
    ]
  },
  {
    "objectID": "feature/appdb.html#routes",
    "href": "feature/appdb.html#routes",
    "title": "appdb",
    "section": "Routes",
    "text": "Routes\n\nsource\n\nAppDb_API_Exception\n\n AppDb_API_Exception (res, message=None)\n\nCommon base class for all non-exit exceptions.\n\n\nExported source\nclass AppDb_API_Exception(dmda.API_Exception):\n    def __init__(self, res, message=None):\n\n        super().__init__(res=res, message=message)\n\n\n\nsource\n\n\nget_collections\n\n get_collections (auth:mbison.client.core.DomoAuth, debug_api:bool=False,\n                  datastore_id:str=None)\n\nretrieve collections\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nauth\nDomoAuth\n\n\n\n\ndebug_api\nbool\nFalse\n\n\n\ndatastore_id\nstr\nNone\nfilters for a specific datastoreId\n\n\n\n\n\nExported source\ndef get_collections(\n    auth: dmda.DomoAuth,\n    debug_api: bool = False,\n    datastore_id : str = None, # filters for a specific datastoreId\n):\n    \"\"\"retrieve collections\"\"\"\n\n    endpoint = f\"/api/datastores/v1/collections/\"\n\n    res =  dmda.domo_api_request(\n        auth=auth,\n        request_type=\"GET\",\n        endpoint= endpoint,\n        debug_api=debug_api,\n        params = {'datastoreId': datastore_id}\n    )\n\n    if not res.is_success and res.status == 400:\n        raise AppDb_API_Exception(res, message = f\"invalid datastoreId  - {datastore_id}?\")\n\n    if not res.is_success:\n        raise AppDb_API_Exception(res)\n    \n    return res\n\n\n\nres = get_collections(auth=auth, debug_api= False,\n                    #   datastore_id = datastore_id\n                      )\ncollections = res.response\ncollections[0:1]\n\n[{'id': '3e6ba7a6-9261-44fd-8eef-987fdbb99e18',\n  'datastoreId': 'de230a76-bc70-404e-b3f4-a6f7dea45723',\n  'defaultPermissions': None,\n  'requiredAuthorities': None,\n  'owner': 826020125,\n  'name': 'ColumnConfig',\n  'datasourceId': None,\n  'schema': None,\n  'filters': None,\n  'syncEnabled': False,\n  'syncRequired': False,\n  'fullReplaceRequired': False,\n  'lastSync': None,\n  'createdOn': '2020-11-20T17:58:42.550Z',\n  'updatedOn': '2023-02-14T20:17:27.920Z',\n  'updatedBy': 826020125}]\n\n\n\nsource\n\n\nget_collection_by_id\n\n get_collection_by_id (auth:mbison.client.core.DomoAuth,\n                       collection_id:str, debug_api:bool=False)\n\n\n\nExported source\ndef get_collection_by_id(\n    auth: dmda.DomoAuth,\n    collection_id : str,\n    debug_api: bool = False,\n):\n\n    endpoint = f\"/api/datastores/v1/collections/{collection_id}\"\n\n    res =  dmda.domo_api_request(\n        auth=auth,\n        request_type=\"GET\",\n        endpoint= endpoint,\n        debug_api=debug_api,\n    )\n\n    if not res.is_success:\n        raise AppDb_API_Exception(res)\n    \n    return res\n\n\n\nres = get_collection_by_id(auth=auth, debug_api= False, \n                        #    collection_id =  collections[0]['id']\n                           collection_id = '0f68f250-df2c-4a15-98ef-9cdd851602eb'\n                             )\n\ncollection = res.response\ncollection\n\n{'id': '0f68f250-df2c-4a15-98ef-9cdd851602eb',\n 'datastoreId': '6aa87886-9167-4191-8491-c9b5bc8bece5',\n 'defaultPermissions': 'read,read_content',\n 'requiredAuthorities': {'CREATE': ['domoapps.edit'],\n  'CREATE_CONTENT': ['domoapps.edit'],\n  'DELETE': ['domoapps.edit'],\n  'DELETE_CONTENT': ['domoapps.edit'],\n  'UPDATE': ['domoapps.edit'],\n  'UPDATE_CONTENT': ['domoapps.edit']},\n 'owner': 1893952720,\n 'name': 'ddx_app_client_code',\n 'datasourceId': None,\n 'schema': None,\n 'filters': None,\n 'syncEnabled': False,\n 'syncRequired': False,\n 'fullReplaceRequired': False,\n 'lastSync': None,\n 'createdOn': '2024-05-30T07:45:21.869Z',\n 'updatedOn': '2024-05-30T07:45:21.869Z',\n 'updatedBy': 1893952720}\n\n\n\nsource\n\n\nquery_collection_documents\n\n query_collection_documents (auth:mbison.client.core.DomoAuth,\n                             collection_id:str, query:dict=None,\n                             debug_api:bool=False)\n\n\n\nExported source\ndef query_collection_documents(\n    auth: dmda.DomoAuth,\n    collection_id: str,\n    query : dict = None,\n    debug_api : bool = False\n):\n    endpoint = f'/api/datastores/v2/collections/{collection_id}/documents/query'\n\n    query = query or {}\n\n    res =  dmda.domo_api_request(\n        auth=auth,\n        request_type=\"POST\",\n        endpoint= endpoint,\n        debug_api=debug_api,\n        body = query\n    )\n\n    if not res.is_success:\n        raise AppDb_API_Exception(res)\n    \n    return res\n\n\n\nres = query_collection_documents(auth=auth,\n                                 debug_api= False,\n                                 collection_id = collection['id']\n                                 )\n\ndocuments = res.response\ndocuments\n\n[{'id': '302663f9-c0bc-4413-894a-3075711b3600',\n  'datastoreId': '6aa87886-9167-4191-8491-c9b5bc8bece5',\n  'collectionId': '0f68f250-df2c-4a15-98ef-9cdd851602eb',\n  'syncRequired': True,\n  'owner': '1893952720',\n  'createdBy': '1893952720',\n  'createdOn': '2024-05-30T07:45:25.355Z',\n  'updatedOn': '2024-05-30T10:14:07.365Z',\n  'updatedBy': '1893952720',\n  'content': {'htmlEasy': {'js': 'fakeEmail = \"ar@test.com\";\\r\\n// fakeEmail = domo.env.userEmail;\\r\\n\\r\\n//Available globals\\r\\nvar domo = window.domo; // For more on domo.js: https://developer.domo.com/docs/dev-studio-guides/domo-js#domo.get\\r\\nvar datasets = window.datasets;\\r\\n\\r\\nlet whoami = domo.env.userId\\r\\nconsole.log(whoami)\\r\\nwhoami = 612085674 //noah\\r\\n\\r\\nSQL_activityLog = \"select `SOURCE_ID` as user_id, `Object_ID` as page_id, count(*) as viewCount FROM dataset1 where `Action` = \\'VIEWED\\' and `Object_Type` = \\'PAGE\\' and `SOURCE_ID` = \\'\" + whoami +\"\\'  GROUP BY `Object_ID`, `Source_ID` ORDER BY count(*)\"\\r\\n\\r\\nfunction mergeRowsColumns(rows, columns) {\\r\\n  return rows.map((row) =&gt; {\\r\\n    let obj = {};\\r\\n    row.forEach((item, index) =&gt; {\\r\\n      obj[columns[index]] = item;\\r\\n    });\\r\\n    return obj;\\r\\n  });\\r\\n}\\r\\n\\r\\nconst get_data = async (sql_str, dataset_alias) =&gt; {\\r\\n  api_str = `/sql/v1/${dataset_alias}`;\\r\\n  console.log(api_str, sql_str);\\r\\n\\r\\n  res = await domo.post(api_str, sql_str, { contentType: \"text/plain\" });\\r\\n\\r\\n  return mergeRowsColumns((rows = res.rows), (columns = res.columns));\\r\\n};\\r\\n\\r\\nconst paint_links = (links)=&gt; {\\r\\n  return links.reduce( (accum, link) =&gt;  {\\r\\n    accum += `&lt;div &gt;${link.page_id}&lt;div&gt;`\\r\\n    return accum } \\r\\n    , \"\")\\r\\n}\\r\\n\\r\\nconst main = async () =&gt; {\\r\\n  const whodiv = document.getElementById(\\'whoami\\')\\r\\n  whodiv.innerHTML = whoami\\r\\n  \\r\\n  const mydiv = document.getElementById(\\'myDiv\\')\\r\\n  \\r\\n  const data = await get_data(sql_str = SQL_activityLog, \\'dataset1\\')\\r\\n  console.log(mydiv)\\r\\n  mydiv.innerHTML = paint_links(data)\\r\\n}\\r\\n\\r\\nmain()',\n    'html': '&lt;div&gt;\\n  &lt;div id = \"whoami\"/&gt;\\n  &lt;div id = \"myDiv\" /&gt;\\n&lt;/div&gt;',\n    'css': '#myDiv {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  background: rgb(131,58,180);\\n\\tbackground: linear-gradient(90deg, rgba(121,64,161,1) 0%, rgba(228,88,80,1) 50%, rgba(251,141,52,1) 100%);\\n  height: calc(100vh);\\n}\\n\\nh1 {\\n  color: white;\\n}'}}}]\n\n\n\nsource\n\n\nget_collection_document_by_id\n\n get_collection_document_by_id (auth:mbison.client.core.DomoAuth,\n                                collection_id:str, document_id:str,\n                                query:dict=None, debug_api:bool=False)\n\n\n\nExported source\ndef get_collection_document_by_id(\n    auth: dmda.DomoAuth,\n    collection_id: str,\n    document_id : str,\n    query : dict = None,\n    debug_api : bool = False\n):\n    endpoint = f'/api/datastores/v2/collections/{collection_id}/documents/{document_id}'\n\n    query = query or {}\n\n    res =  dmda.domo_api_request(\n        auth=auth,\n        request_type=\"GET\",\n        endpoint= endpoint,\n        debug_api=debug_api,\n        body = query\n    )\n\n    if not res.is_success:\n        raise AppDb_API_Exception(res)\n    \n    return res\n\n\n\nres = get_collection_document_by_id(auth=auth,\n                                 debug_api= False,\n                                 collection_id = documents[0]['collectionId'],\n                                 document_id = documents[0]['id']\n                                 )\n\ndocument = res.response\ndocument\n\n{'id': '302663f9-c0bc-4413-894a-3075711b3600',\n 'datastoreId': '6aa87886-9167-4191-8491-c9b5bc8bece5',\n 'collectionId': '0f68f250-df2c-4a15-98ef-9cdd851602eb',\n 'syncRequired': True,\n 'owner': '1893952720',\n 'createdBy': '1893952720',\n 'createdOn': '2024-05-30T07:45:25.355Z',\n 'updatedOn': '2024-05-30T10:14:07.365Z',\n 'updatedBy': '1893952720',\n 'content': {'htmlEasy': {'js': 'fakeEmail = \"ar@test.com\";\\r\\n// fakeEmail = domo.env.userEmail;\\r\\n\\r\\n//Available globals\\r\\nvar domo = window.domo; // For more on domo.js: https://developer.domo.com/docs/dev-studio-guides/domo-js#domo.get\\r\\nvar datasets = window.datasets;\\r\\n\\r\\nlet whoami = domo.env.userId\\r\\nconsole.log(whoami)\\r\\nwhoami = 612085674 //noah\\r\\n\\r\\nSQL_activityLog = \"select `SOURCE_ID` as user_id, `Object_ID` as page_id, count(*) as viewCount FROM dataset1 where `Action` = \\'VIEWED\\' and `Object_Type` = \\'PAGE\\' and `SOURCE_ID` = \\'\" + whoami +\"\\'  GROUP BY `Object_ID`, `Source_ID` ORDER BY count(*)\"\\r\\n\\r\\nfunction mergeRowsColumns(rows, columns) {\\r\\n  return rows.map((row) =&gt; {\\r\\n    let obj = {};\\r\\n    row.forEach((item, index) =&gt; {\\r\\n      obj[columns[index]] = item;\\r\\n    });\\r\\n    return obj;\\r\\n  });\\r\\n}\\r\\n\\r\\nconst get_data = async (sql_str, dataset_alias) =&gt; {\\r\\n  api_str = `/sql/v1/${dataset_alias}`;\\r\\n  console.log(api_str, sql_str);\\r\\n\\r\\n  res = await domo.post(api_str, sql_str, { contentType: \"text/plain\" });\\r\\n\\r\\n  return mergeRowsColumns((rows = res.rows), (columns = res.columns));\\r\\n};\\r\\n\\r\\nconst paint_links = (links)=&gt; {\\r\\n  return links.reduce( (accum, link) =&gt;  {\\r\\n    accum += `&lt;div &gt;${link.page_id}&lt;div&gt;`\\r\\n    return accum } \\r\\n    , \"\")\\r\\n}\\r\\n\\r\\nconst main = async () =&gt; {\\r\\n  const whodiv = document.getElementById(\\'whoami\\')\\r\\n  whodiv.innerHTML = whoami\\r\\n  \\r\\n  const mydiv = document.getElementById(\\'myDiv\\')\\r\\n  \\r\\n  const data = await get_data(sql_str = SQL_activityLog, \\'dataset1\\')\\r\\n  console.log(mydiv)\\r\\n  mydiv.innerHTML = paint_links(data)\\r\\n}\\r\\n\\r\\nmain()',\n   'html': '&lt;div&gt;\\n  &lt;div id = \"whoami\"/&gt;\\n  &lt;div id = \"myDiv\" /&gt;\\n&lt;/div&gt;',\n   'css': '#myDiv {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  background: rgb(131,58,180);\\n\\tbackground: linear-gradient(90deg, rgba(121,64,161,1) 0%, rgba(228,88,80,1) 50%, rgba(251,141,52,1) 100%);\\n  height: calc(100vh);\\n}\\n\\nh1 {\\n  color: white;\\n}'}}}\n\n\n\n\nClasses\n\nsource\n\n\nAppDbDocument\n\n AppDbDocument (auth:mbison.client.core.DomoAuth, _collection_id:str,\n                _identity_columns:List[str], _id:str=None,\n                _created_on_dt:datetime.datetime=None,\n                _updated_on_dt:datetime.datetime=None, content:dict=None)\n\n\n\nExported source\ndef to_json(value):\n    \"\"\"\n    converts complex dictionaries with nested classes to dictionary.\n    assumes nested classes have a `to_json` method\n    \"\"\"\n\n    if hasattr(value, \"to_json\"):\n        return value.to_json()\n\n    if isinstance(value, dict):\n        return {key: to_json(v) for key, v in value.items()}\n\n    if isinstance(value, list):\n        return [to_json(v) for v in value]\n\n    if isinstance(value, Number):\n        return value\n\n    return str(value)\n\n\n@dataclass\nclass AppDbDocument:\n\n    auth: dmda.DomoAuth = field(repr=False)\n\n    # document metadata\n    _collection_id: str\n    _identity_columns: List[str]\n    _id: str = None\n    _created_on_dt: dt.datetime = None\n    _updated_on_dt: dt.datetime = None\n\n    content: dict = None\n\n    def to_json(self):\n        # TO DO - this is not a complete recursive implementation,  may need revision for complex dictionaries\n        self.update_config()\n\n        s = {\"id\": self._id, \"collectionId\": self._collection_id}\n\n        for key, value in self.__dict__.items():\n            if key.startswith(\"_\") or key in [\"auth\"]:\n                continue\n\n            s.update({key: to_json(value)})\n\n        return s\n\n    def __eq__(self, other):\n        if self.__class__.__name__ != other.__class__.__name__:\n            return False\n\n        if self._identity_columns:\n            return all(\n                getattr(self, col) == getattr(other.col)\n                for col in self._identity_columns\n            )\n\n        return self._id == other._id\n\n    @classmethod\n    def _from_json(\n        cls,\n        auth: dmda.DomoAuth,\n        content,\n        new_cls,\n        identity_columns,\n        collection_id=None,\n        document_id=None,\n        metadata=None,\n        created_on_dt=None,\n        updated_on_dt=None,\n    ):\n\n        if metadata:\n            collection_id = metadata.pop(\"collectionId\")\n\n            created_on_dt = dmut.convert_string_to_datetime(metadata.pop(\"createdOn\"))\n\n            updated_on_dt = dmut.convert_string_to_datetime(metadata.pop(\"updatedOn\"))\n            document_id = metadata[\"id\"]\n\n        return new_cls(\n            auth=auth,\n            _id=document_id,\n            _identity_columns=identity_columns,\n            _collection_id=collection_id,\n            _created_on_dt=created_on_dt,\n            _updated_on_dt=updated_on_dt,\n            content=content,\n            **(content if cls.__name__ != \"AppDbDocument\" else {})\n        )\n\n    @classmethod\n    def _from_api(\n        cls,\n        auth: dmda.DomoAuth,\n        obj,\n        identity_columns: List[str] = None,\n    ):\n        content = obj.pop(\"content\")\n\n        return cls._from_json(\n            auth=auth,\n            content=content,\n            new_cls=cls,\n            identity_columns=identity_columns,\n            metadata=obj,\n        )\n\n    @classmethod\n    def from_json(\n        cls,\n        auth: dmda.DomoAuth,\n        collection_id: str,\n        content: dict,\n        identity_columns: List[str] = None,\n    ):\n        return cls._from_json(\n            auth=auth,\n            content=content,\n            new_cls=cls,\n            identity_columns=identity_columns,\n            collection_id=collection_id,\n        )\n\n    def update_config(self):\n        self.content = {\n            key: value\n            for key, value in self.__dict__.items()\n            if key not in [\"auth\", \"content\"] and not key.startswith(\"_\")\n        }\n        return self.content\n\n    @classmethod\n    def get_by_id(\n        cls,\n        collection_id: str,\n        document_id: str,\n        auth: dmda.DomoAuth,\n        identity_columns=None,\n        debug_api: bool = False,\n        return_raw: bool = False,\n    ):\n        res = get_collection_document_by_id(\n            auth=auth,\n            collection_id=collection_id,\n            document_id=document_id,\n            debug_api=debug_api,\n        )\n\n        if return_raw:\n            return res\n\n        return cls._from_api(\n            auth=auth,\n            obj=res.response,\n            identity_columns=identity_columns or [],\n        )\n\n\n\nsource\n\n\nto_json\n\n to_json (value)\n\nconverts complex dictionaries with nested classes to dictionary. assumes nested classes have a to_json method\n\nAppDbDocument.get_by_id(\n    auth = auth,\n    debug_api= False,\n    collection_id = document['collectionId'],\n    document_id = document['id'])\n\nAppDbDocument(_collection_id='0f68f250-df2c-4a15-98ef-9cdd851602eb', _identity_columns=[], _id='302663f9-c0bc-4413-894a-3075711b3600', _created_on_dt=datetime.datetime(2024, 5, 30, 7, 45, 25, 355000, tzinfo=tzutc()), _updated_on_dt=datetime.datetime(2024, 5, 30, 10, 14, 7, 365000, tzinfo=tzutc()), content={'htmlEasy': {'js': 'fakeEmail = \"ar@test.com\";\\r\\n// fakeEmail = domo.env.userEmail;\\r\\n\\r\\n//Available globals\\r\\nvar domo = window.domo; // For more on domo.js: https://developer.domo.com/docs/dev-studio-guides/domo-js#domo.get\\r\\nvar datasets = window.datasets;\\r\\n\\r\\nlet whoami = domo.env.userId\\r\\nconsole.log(whoami)\\r\\nwhoami = 612085674 //noah\\r\\n\\r\\nSQL_activityLog = \"select `SOURCE_ID` as user_id, `Object_ID` as page_id, count(*) as viewCount FROM dataset1 where `Action` = \\'VIEWED\\' and `Object_Type` = \\'PAGE\\' and `SOURCE_ID` = \\'\" + whoami +\"\\'  GROUP BY `Object_ID`, `Source_ID` ORDER BY count(*)\"\\r\\n\\r\\nfunction mergeRowsColumns(rows, columns) {\\r\\n  return rows.map((row) =&gt; {\\r\\n    let obj = {};\\r\\n    row.forEach((item, index) =&gt; {\\r\\n      obj[columns[index]] = item;\\r\\n    });\\r\\n    return obj;\\r\\n  });\\r\\n}\\r\\n\\r\\nconst get_data = async (sql_str, dataset_alias) =&gt; {\\r\\n  api_str = `/sql/v1/${dataset_alias}`;\\r\\n  console.log(api_str, sql_str);\\r\\n\\r\\n  res = await domo.post(api_str, sql_str, { contentType: \"text/plain\" });\\r\\n\\r\\n  return mergeRowsColumns((rows = res.rows), (columns = res.columns));\\r\\n};\\r\\n\\r\\nconst paint_links = (links)=&gt; {\\r\\n  return links.reduce( (accum, link) =&gt;  {\\r\\n    accum += `&lt;div &gt;${link.page_id}&lt;div&gt;`\\r\\n    return accum } \\r\\n    , \"\")\\r\\n}\\r\\n\\r\\nconst main = async () =&gt; {\\r\\n  const whodiv = document.getElementById(\\'whoami\\')\\r\\n  whodiv.innerHTML = whoami\\r\\n  \\r\\n  const mydiv = document.getElementById(\\'myDiv\\')\\r\\n  \\r\\n  const data = await get_data(sql_str = SQL_activityLog, \\'dataset1\\')\\r\\n  console.log(mydiv)\\r\\n  mydiv.innerHTML = paint_links(data)\\r\\n}\\r\\n\\r\\nmain()', 'html': '&lt;div&gt;\\n  &lt;div id = \"whoami\"/&gt;\\n  &lt;div id = \"myDiv\" /&gt;\\n&lt;/div&gt;', 'css': '#myDiv {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  background: rgb(131,58,180);\\n\\tbackground: linear-gradient(90deg, rgba(121,64,161,1) 0%, rgba(228,88,80,1) 50%, rgba(251,141,52,1) 100%);\\n  height: calc(100vh);\\n}\\n\\nh1 {\\n  color: white;\\n}'}})\n\n\n\nsource\n\n\nAppDbCollection\n\n AppDbCollection (auth:mbison.client.core.DomoAuth, id:str, name:str,\n                  created_on_dt:datetime.datetime,\n                  updated_on_dt:datetime.datetime, schema:dict,\n                  domo_documents:List[__main__.AppDbDocument]=None)\n\n\n\nExported source\n@dataclass\nclass AppDbCollection:\n    auth: dmda.DomoAuth = field(repr=False)\n    id: str\n    name: str\n\n    created_on_dt: dt.datetime\n    updated_on_dt: dt.datetime\n\n    schema: dict\n\n    domo_documents: List[AppDbDocument] = None\n\n    @classmethod\n    def _from_json(cls, auth, obj):\n\n        return cls(\n            auth=auth,\n            id=obj[\"id\"],\n            name=obj[\"name\"],\n            created_on_dt=dmut.convert_string_to_datetime(obj[\"createdOn\"]),\n            updated_on_dt=dmut.convert_string_to_datetime(obj[\"updatedOn\"]),\n            schema=obj[\"schema\"],\n        )\n\n    @classmethod\n    def get_by_id(\n        cls,\n        auth: dmda.DomoAuth,\n        collection_id,\n        debug_api: bool = False,\n        return_raw: bool = False,\n    ):\n\n        res = get_collection_by_id(\n            auth=auth,\n            collection_id=collection_id,\n            debug_api=debug_api,\n        )\n\n        if return_raw:\n            return res\n\n        return cls._from_json(auth=auth, obj=res.response)\n\n    def query_documents(\n        self,\n        debug_api: bool = False,\n        query: dict=None,\n        return_raw: bool = False,\n    ):\n\n        res = query_collection_documents(\n            auth=self.auth,\n            collection_id=self.id,\n            debug_api=debug_api,\n            query=query,\n        )\n\n        if return_raw:\n            return res\n\n        self.domo_documents = [\n                AppDbDocument.get_by_id(\n                    collection_id=self.id,\n                    document_id=doc[\"id\"], auth=self.auth\n                )\n                for doc in res.response\n            ]\n        \n        return self.domo_documents\n\n    def __eq__(self, other):\n        if not isinstance(other, AppDbCollection):\n            return False\n\n        return self.id == other.id\n\n\n\ndomo_collection = AppDbCollection.get_by_id(auth = auth, \n                          collection_id= document['collectionId'],\n                          debug_api= False\n                          )\n\ndomo_collection.query_documents()\n\n[AppDbDocument(_collection_id='0f68f250-df2c-4a15-98ef-9cdd851602eb', _identity_columns=[], _id='302663f9-c0bc-4413-894a-3075711b3600', _created_on_dt=datetime.datetime(2024, 5, 30, 7, 45, 25, 355000, tzinfo=tzutc()), _updated_on_dt=datetime.datetime(2024, 5, 30, 10, 14, 7, 365000, tzinfo=tzutc()), content={'htmlEasy': {'js': 'fakeEmail = \"ar@test.com\";\\r\\n// fakeEmail = domo.env.userEmail;\\r\\n\\r\\n//Available globals\\r\\nvar domo = window.domo; // For more on domo.js: https://developer.domo.com/docs/dev-studio-guides/domo-js#domo.get\\r\\nvar datasets = window.datasets;\\r\\n\\r\\nlet whoami = domo.env.userId\\r\\nconsole.log(whoami)\\r\\nwhoami = 612085674 //noah\\r\\n\\r\\nSQL_activityLog = \"select `SOURCE_ID` as user_id, `Object_ID` as page_id, count(*) as viewCount FROM dataset1 where `Action` = \\'VIEWED\\' and `Object_Type` = \\'PAGE\\' and `SOURCE_ID` = \\'\" + whoami +\"\\'  GROUP BY `Object_ID`, `Source_ID` ORDER BY count(*)\"\\r\\n\\r\\nfunction mergeRowsColumns(rows, columns) {\\r\\n  return rows.map((row) =&gt; {\\r\\n    let obj = {};\\r\\n    row.forEach((item, index) =&gt; {\\r\\n      obj[columns[index]] = item;\\r\\n    });\\r\\n    return obj;\\r\\n  });\\r\\n}\\r\\n\\r\\nconst get_data = async (sql_str, dataset_alias) =&gt; {\\r\\n  api_str = `/sql/v1/${dataset_alias}`;\\r\\n  console.log(api_str, sql_str);\\r\\n\\r\\n  res = await domo.post(api_str, sql_str, { contentType: \"text/plain\" });\\r\\n\\r\\n  return mergeRowsColumns((rows = res.rows), (columns = res.columns));\\r\\n};\\r\\n\\r\\nconst paint_links = (links)=&gt; {\\r\\n  return links.reduce( (accum, link) =&gt;  {\\r\\n    accum += `&lt;div &gt;${link.page_id}&lt;div&gt;`\\r\\n    return accum } \\r\\n    , \"\")\\r\\n}\\r\\n\\r\\nconst main = async () =&gt; {\\r\\n  const whodiv = document.getElementById(\\'whoami\\')\\r\\n  whodiv.innerHTML = whoami\\r\\n  \\r\\n  const mydiv = document.getElementById(\\'myDiv\\')\\r\\n  \\r\\n  const data = await get_data(sql_str = SQL_activityLog, \\'dataset1\\')\\r\\n  console.log(mydiv)\\r\\n  mydiv.innerHTML = paint_links(data)\\r\\n}\\r\\n\\r\\nmain()', 'html': '&lt;div&gt;\\n  &lt;div id = \"whoami\"/&gt;\\n  &lt;div id = \"myDiv\" /&gt;\\n&lt;/div&gt;', 'css': '#myDiv {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  background: rgb(131,58,180);\\n\\tbackground: linear-gradient(90deg, rgba(121,64,161,1) 0%, rgba(228,88,80,1) 50%, rgba(251,141,52,1) 100%);\\n  height: calc(100vh);\\n}\\n\\nh1 {\\n  color: white;\\n}'}})]",
    "crumbs": [
      "feature",
      "appdb"
    ]
  },
  {
    "objectID": "feature/enterprise_apps.html",
    "href": "feature/enterprise_apps.html",
    "title": "EnterpriseApps",
    "section": "",
    "text": "auth = dmda.DomoAuth(\n    domo_instance=os.environ[\"DOMO_INSTANCE\"],\n    access_token=os.environ[\"DOMO_ACCESS_TOKEN\"],\n)\nauth\n\ndesign_id = \"8c16c8ab-c068-4110-940b-f738d7146efc\"",
    "crumbs": [
      "feature",
      "EnterpriseApps"
    ]
  },
  {
    "objectID": "feature/enterprise_apps.html#routes",
    "href": "feature/enterprise_apps.html#routes",
    "title": "EnterpriseApps",
    "section": "Routes",
    "text": "Routes\n\nsource\n\nget_app_by_id\n\n get_app_by_id (auth:mbison.client.core.DomoAuth, design_id:str,\n                debug_api:bool=False)\n\n\n\nExported source\nclass App_API_Exception(dmda.API_Exception):\n    def __init__(self, res, message= None):\n        super().__init__(res = res,message = message)\n\ndef get_app_by_id(auth: dmda.DomoAuth, design_id: str, debug_api: bool = False):\n\n    endpoint = f\"/api/apps/v1/designs/{design_id}\"\n\n    res = dmda.domo_api_request(\n        endpoint=endpoint,\n        request_type=\"get\",\n        auth=auth,\n        debug_api=debug_api,\n    )\n\n    if not res.is_success:\n        raise App_API_Exception(res = res, message =\"is app shared with authenticated user?\")\n\n    return res\n\n\n\nsource\n\n\nApp_API_Exception\n\n App_API_Exception (res, message=None)\n\nCommon base class for all non-exit exceptions.\n\ndomo_app = get_app_by_id(auth=auth, design_id=design_id, debug_api=False).response\ndomo_app\n\n{'id': '8c16c8ab-c068-4110-940b-f738d7146efc',\n 'name': 'nbdev_documentation',\n 'owner': '1893952720',\n 'createdBy': '1893952720',\n 'createdDate': '2022-12-02T17:26:03Z',\n 'updatedBy': '1893952720',\n 'updatedDate': '2022-12-02T17:39:38Z',\n 'description': None,\n 'versions': [],\n 'latestVersion': '1.0.0',\n 'instances': [],\n 'referencingCards': [],\n 'owners': [],\n 'creator': None,\n 'deletedDate': None,\n 'trusted': False,\n 'hasThumbnail': None}\n\n\n\nsource\n\n\nget_app_versions\n\n get_app_versions (auth:mbison.client.core.DomoAuth, design_id,\n                   debug_api:bool=False)\n\n\n\nExported source\ndef get_app_versions(auth: dmda.DomoAuth, design_id, debug_api: bool = False):\n\n    endpoint = f\"/domoapps/designs/{design_id}/versions\"\n\n    return dmda.domo_api_request(\n        endpoint=endpoint, auth=auth, request_type=\"get\", debug_api=debug_api\n    )\n\n\n\napp_versions = get_app_versions(\n    auth=auth,\n    # design_id=domo_app[\"id\"]\n    design_id=design_id,\n).response\n\napp_versions\n\n['1.0.0']\n\n\n\nsource\n\n\nget_app_source_by_version\n\n get_app_source_by_version (auth:mbison.client.core.DomoAuth,\n                            download_path, design_id, version,\n                            debug_api:bool=False)\n\n\n\nExported source\ndef get_app_source_by_version(\n    auth: dmda.DomoAuth,\n    download_path,\n    design_id,\n    version,\n    debug_api: bool = False,\n):\n\n    download_path = dmut.change_suffix(download_path, \".zip\")\n\n    endpoint = f\"/domoapps/designs/{design_id}/versions/{version}/assets\"\n\n    res = dmda.domo_api_stream_request(\n        endpoint=endpoint,\n        request_type=\"get\",\n        auth=auth,\n        debug_api=debug_api,\n        download_path=download_path,\n    )\n\n    if not res.is_success:\n        raise App_API_Exception(res = res, message = f\"unable to download assets for {design_id}\")\n\n    return res\n\n\n\nres = get_app_source_by_version(\n    auth=auth,\n    design_id=design_id,\n    version=app_versions[0],\n    debug_api=False,\n    download_path=\"../../TEST/route.zip\",\n)\n\ndone writing stream\n\n\n\nsource\n\n\nget_all_apps\n\n get_all_apps (auth:mbison.client.core.DomoAuth, debug_api:bool=False)\n\n\n\nExported source\ndef get_all_apps(auth: dmda.DomoAuth, debug_api: bool = False):\n\n    endpoint = \"/api/apps/v1/designs\"\n\n    params = {\n        \"checkAdminAuthority\" : True, \n        \"deleted\": False,\n        \"direction\" : \"desc\",\n        # \"parts\" : \"owners,creator,thumbnail\",\n        \"search\" : \"\",\n        \"withPermission\" : \"ADMIN\"}\n\n\n    res = dmda.domo_api_request(\n        endpoint=endpoint,\n        request_type=\"get\",\n        params=params,\n        auth=auth,\n        debug_api=debug_api,\n    )\n\n\n    return res\n\n\n\ndef get_app_permissions(design_id, auth : dmda.DomoAuth, debug_api: bool = False):\n    endpoint = f'/api/apps/v1/designs/{design_id}/permissions'\n\n    res = dmda.domo_api_request(\n        endpoint=endpoint,\n        request_type=\"get\",\n        auth=auth,\n        debug_api=debug_api,\n    )\n\n    if not res.is_success:\n        raise App_API_Exception(res = res)\n    \n    return res\n\n\ndesign_id = 'aace1266-dc7f-42cb-8595-46069d91a703'\n\nget_app_permissions(\n    design_id= design_id,\n    auth = auth\n)\n\n\n---------------------------------------------------------------------------\nApp_API_Exception                         Traceback (most recent call last)\nCell In[21], line 3\n      1 design_id = 'aace1266-dc7f-42cb-8595-46069d91a703'\n----&gt; 3 get_app_permissions(\n      4     design_id= design_id,\n      5     auth = auth\n      6 )\n\nCell In[20], line 12, in get_app_permissions(design_id, auth, debug_api)\n      4 res = dmda.domo_api_request(\n      5     endpoint=endpoint,\n      6     request_type=\"get\",\n      7     auth=auth,\n      8     debug_api=debug_api,\n      9 )\n     11 if not res.is_success:\n---&gt; 12     raise App_API_Exception(res = res)\n     14 return res\n\nApp_API_Exception:  || 404 - No static resource api/apps/v1/designs/aace1266-dc7f-42cb-8595-46069d91a703/permissions. || domo-community\n\n\n\n\ndef share_app(auth : dm):\nurl = 'https://domo-community.domo.com/api/apps/v1/designs/dde86741-c198-4b9e-8686-cc60f8dfd5be/permissions/ADMIN'",
    "crumbs": [
      "feature",
      "EnterpriseApps"
    ]
  },
  {
    "objectID": "feature/enterprise_apps.html#classes",
    "href": "feature/enterprise_apps.html#classes",
    "title": "EnterpriseApps",
    "section": "Classes",
    "text": "Classes\n\nsource\n\nDomoEnterpriseApp\n\n DomoEnterpriseApp (auth:mbison.client.core.DomoAuth, id:str, name:str,\n                    owner:mbison.feature.users.DomoUser,\n                    created_dt:datetime.datetime,\n                    lastmodified_dt:datetime.datetime, versions:List[str],\n                    current_version:str, referencing_cards:List[dict])\n\n\n\nExported source\n@dataclass\nclass DomoEnterpriseApp:\n    auth: dmda.DomoAuth = field(repr=False)\n    id: str\n    name: str\n    owner: dmdu.DomoUser\n    created_dt: dt.datetime\n    lastmodified_dt: dt.datetime\n    versions: List[str]\n    current_version: str\n    referencing_cards: List[dict]\n\n    @classmethod\n    def _from_json(cls, obj, auth: dmda.DomoAuth, debug_api: bool = False):\n\n        domo_user = None\n\n        try:\n            if obj.get(\"owner\"):\n                domo_user = dmdu.DomoUser.get_by_id(\n                    user_id=obj[\"owner\"], auth=auth, debug_api=debug_api\n                )\n\n        except dmdu.User_API_Exception as e:\n            print(e)\n\n        return cls(\n            auth=auth,\n            id=obj[\"id\"],\n            name=obj[\"name\"],\n            owner=domo_user,\n            created_dt=obj[\"createdDate\"],\n            lastmodified_dt=obj[\"updatedDate\"],\n            versions=obj[\"versions\"],\n            current_version=obj[\"latestVersion\"],\n            referencing_cards=obj[\"referencingCards\"],\n        )\n\n    @classmethod\n    def get_by_id(\n        cls,\n        design_id,\n        auth: dmda.DomoAuth,\n        debug_api: bool = False,\n        return_raw: bool = False,\n    ):\n        res = get_app_by_id(auth=auth, design_id=design_id, debug_api=debug_api)\n\n        if return_raw:\n            return res\n\n        return cls._from_json(obj=res.response, auth=auth, debug_api=debug_api)\n\n    def get_source_code(\n        self,\n        version: str = None,\n        debug_api: bool = False,\n        download_folder=\"./EXPORT/\",\n        file_name=None,\n    ):\n\n        file_name = file_name or f\"{self.id} - {version or self.current_version}.zip\"\n        file_name = dmut.change_suffix(file_name, \".zip\")\n\n        download_path = os.path.join(download_folder, file_name)\n        \n        return get_app_source_by_version(\n            auth=self.auth,\n            download_path=download_path,\n            design_id=self.id,\n            version=version or self.current_version,\n            debug_api=debug_api,\n        )\n\n\n    def get_versions(self, debug_api: bool = False, return_raw: bool = False):\n\n        res = get_app_versions(auth=self.auth, design_id=self.id, debug_api=debug_api)\n        if return_raw:\n            return res\n\n        self.versions = res.response\n        return self.versions\n\n\n\n# design_id = '897f9ffc-1ce2-4247-94d3-7afcb0192abb'\ndomo_app = DomoEnterpriseApp.get_by_id(design_id = design_id, auth = auth)\n\ndomo_app.get_versions()\ndomo_app.current_version = domo_app.versions[-1]\ndomo_app\n\nDomoEnterpriseApp(id='8c16c8ab-c068-4110-940b-f738d7146efc', name='nbdev_documentation', owner=DomoUser(id=1893952720, display_name='Jae Wilson1', role_id=810756122, email='jae@datacrew.space'), created_dt='2022-12-02T17:26:03Z', lastmodified_dt='2022-12-02T17:39:38Z', versions=['1.0.0'], current_version='1.0.0', referencing_cards=[])\n\n\n\ndomo_app.get_source_code(download_folder='../../TEST')\n\ndone writing stream\n\n\nResponseGetData(response=True, is_success=True, status=200, download_path='..\\\\..\\\\TEST\\\\8c16c8ab-c068-4110-940b-f738d7146efc - 1.0.0.zip')\n\n\n\nsource\n\n\nDomoEnterpriseApps\n\n DomoEnterpriseApps (auth:mbison.client.core.DomoAuth,\n                     enterprise_apps:List[__main__.DomoEnterpriseApp]=None\n                     )\n\n\nDomoEnterpriseApps(auth = auth).get_apps(debug_api = False, return_raw = False)[0:5]\n\n[DomoEnterpriseApp(id='e09d6625-3680-4fac-bc71-1cd81607eb9a', name='YouTubeViewer Demographic', owner=None, created_dt='2016-07-19T22:10:36Z', lastmodified_dt='2016-09-20T21:41:39Z', versions=[], current_version='1.0.7', referencing_cards=[]),\n DomoEnterpriseApp(id='f0b9f8b5-3dac-43c1-8e6e-fe2a7c8e248e', name='iframeApp', owner=None, created_dt='2018-04-24T21:41:02Z', lastmodified_dt='2018-04-24T21:41:02Z', versions=[], current_version='1.0.0', referencing_cards=[]),\n DomoEnterpriseApp(id='e2fca4a6-f099-4bba-8163-1b88fb53d427', name='Inline Editing', owner=None, created_dt='2020-11-17T20:16:32Z', lastmodified_dt='2023-10-03T18:58:42Z', versions=[], current_version='5.1.4', referencing_cards=[]),\n DomoEnterpriseApp(id='883bec29-4d9c-4caf-b144-9b3a6d07a001', name='form-builder-master', owner=None, created_dt='2019-12-05T23:18:19Z', lastmodified_dt='2024-07-08T16:37:47Z', versions=[], current_version='3.2.7', referencing_cards=[]),\n DomoEnterpriseApp(id='c5aa00cc-8c6b-4571-a5cf-6ae5ddcf56a8', name='sugarforce', owner=DomoUser(id=1141078945, display_name='Justin Pumford', role_id=2097317660, email='jpumford@gmail.com'), created_dt='2021-04-14T02:59:48Z', lastmodified_dt='2021-04-14T02:59:49Z', versions=[], current_version='0.1.0', referencing_cards=[])]",
    "crumbs": [
      "feature",
      "EnterpriseApps"
    ]
  }
]